{"ts":1367326679358,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1367326748944,"patch":[[{"diffs":[[1,";(function(){\r\n\r\n/**\r\n * Require the given path.\r\n *\r\n * @param {String} path\r\n * @return {Object} exports\r\n * @api public\r\n */\r\n\r\nfunction require(path, parent, orig) {\r\n  var resolved = require.resolve(path);\r\n\r\n  // lookup failed\r\n  if (null == resolved) {\r\n    orig = orig || path;\r\n    parent = parent || 'root';\r\n    var err = new Error('Failed to require \"' + orig + '\" from \"' + parent + '\"');\r\n    err.path = orig;\r\n    err.parent = parent;\r\n    err.require = true;\r\n    throw err;\r\n  }\r\n\r\n  var module = require.modules[resolved];\r\n\r\n  // perform real require()\r\n  // by invoking the module's\r\n  // registered function\r\n  if (!module.exports) {\r\n    module.exports = {};\r\n    module.client = module.component = true;\r\n    module.call(this, module.exports, require.relative(resolved), module);\r\n  }\r\n\r\n  return module.exports;\r\n}\r\n\r\n/**\r\n * Registered modules.\r\n */\r\n\r\nrequire.modules = {};\r\n\r\n/**\r\n * Registered aliases.\r\n */\r\n\r\nrequire.aliases = {};\r\n\r\n/**\r\n * Resolve `path`.\r\n *\r\n * Lookup:\r\n *\r\n *   - PATH/index.js\r\n *   - PATH.js\r\n *   - PATH\r\n *\r\n * @param {String} path\r\n * @return {String} path or null\r\n * @api private\r\n */\r\n\r\nrequire.resolve = function(path) {\r\n  if (path.charAt(0) === '/') path = path.slice(1);\r\n  var index = path + '/index.js';\r\n\r\n  var paths = [\r\n    path,\r\n    path + '.js',\r\n    path + '.json',\r\n    path + '/index.js',\r\n    path + '/index.json'\r\n  ];\r\n\r\n  for (var i = 0; i < paths.length; i++) {\r\n    var path = paths[i];\r\n    if (require.modules.hasOwnProperty(path)) return path;\r\n  }\r\n\r\n  if (require.aliases.hasOwnProperty(index)) {\r\n    return require.aliases[index];\r\n  }\r\n};\r\n\r\n/**\r\n * Normalize `path` relative to the current path.\r\n *\r\n * @param {String} curr\r\n * @param {String} path\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nrequire.normalize = function(curr, path) {\r\n  var segs = [];\r\n\r\n  if ('.' != path.charAt(0)) return path;\r\n\r\n  curr = curr.split('/');\r\n  path = path.split('/');\r\n\r\n  for (var i = 0; i < path.length; ++i) {\r\n    if ('..' == path[i]) {\r\n      curr.pop();\r\n    } else if ('.' != path[i] && '' != path[i]) {\r\n      segs.push(path[i]);\r\n    }\r\n  }\r\n\r\n  return curr.concat(segs).join('/');\r\n};\r\n\r\n/**\r\n * Register module at `path` with callback `definition`.\r\n *\r\n * @param {String} path\r\n * @param {Function} definition\r\n * @api private\r\n */\r\n\r\nrequire.register = function(path, definition) {\r\n  require.modules[path] = definition;\r\n};\r\n\r\n/**\r\n * Alias a module definition.\r\n *\r\n * @param {String} from\r\n * @param {String} to\r\n * @api private\r\n */\r\n\r\nrequire.alias = function(from, to) {\r\n  if (!require.modules.hasOwnProperty(from)) {\r\n    throw new Error('Failed to alias \"' + from + '\", it does not exist');\r\n  }\r\n  require.aliases[to] = from;\r\n};\r\n\r\n/**\r\n * Return a require function relative to the `parent` path.\r\n *\r\n * @param {String} parent\r\n * @return {Function}\r\n * @api private\r\n */\r\n\r\nrequire.relative = function(parent) {\r\n  var p = require.normalize(parent, '..');\r\n\r\n  /**\r\n   * lastIndexOf helper.\r\n   */\r\n\r\n  function lastIndexOf(arr, obj) {\r\n    var i = arr.length;\r\n    while (i--) {\r\n      if (arr[i] === obj) return i;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * The relative require() itself.\r\n   */\r\n\r\n  function localRequire(path) {\r\n    var resolved = localRequire.resolve(path);\r\n    return require(resolved, parent, path);\r\n  }\r\n\r\n  /**\r\n   * Resolve relative to the parent.\r\n   */\r\n\r\n  localRequire.resolve = function(path) {\r\n    var c = path.charAt(0);\r\n    if ('/' == c) return path.slice(1);\r\n    if ('.' == c) return require.normalize(p, path);\r\n\r\n    // resolve deps by returning\r\n    // the dep in the nearest \"deps\"\r\n    // directory\r\n    var segs = parent.split('/');\r\n    var i = lastIndexOf(segs, 'deps') + 1;\r\n    if (!i) i = 0;\r\n    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;\r\n    return path;\r\n  };\r\n\r\n  /**\r\n   * Check if module is defined at `path`.\r\n   */\r\n\r\n  localRequire.exists = function(path) {\r\n    return require.modules.hasOwnProperty(localRequire.resolve(path));\r\n  };\r\n\r\n  return localRequire;\r\n};\r\nrequire.register(\"chai/index.js\", function(exports, require, module){\r\nmodule.exports = require('./lib/chai');\r\n\r\n});\r\nrequire.register(\"chai/lib/chai.js\", function(exports, require, module){\r\n/*!\r\n * chai\r\n * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\nvar used = []\r\n  , exports = module.exports = {};\r\n\r\n/*!\r\n * Chai version\r\n */\r\n\r\nexports.version = '1.6.0';\r\n\r\n/*!\r\n * Primary `Assertion` prototype\r\n */\r\n\r\nexports.Assertion = require('./chai/assertion');\r\n\r\n/*!\r\n * Assertion Error\r\n */\r\n\r\nexports.AssertionError = require('./chai/error');\r\n\r\n/*!\r\n * Utils for plugins (not exported)\r\n */\r\n\r\nvar util = require('./chai/utils');\r\n\r\n/**\r\n * # .use(function)\r\n *\r\n * Provides a way to extend the internals of Chai\r\n *\r\n * @param {Function}\r\n * @returns {this} for chaining\r\n * @api public\r\n */\r\n\r\nexports.use = function (fn) {\r\n  if (!~used.indexOf(fn)) {\r\n    fn(this, util);\r\n    used.push(fn);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/*!\r\n * Core Assertions\r\n */\r\n\r\nvar core = require('./chai/core/assertions');\r\nexports.use(core);\r\n\r\n/*!\r\n * Expect interface\r\n */\r\n\r\nvar expect = require('./chai/interface/expect');\r\nexports.use(expect);\r\n\r\n/*!\r\n * Should interface\r\n */\r\n\r\nvar should = require('./chai/interface/should');\r\nexports.use(should);\r\n\r\n/*!\r\n * Assert interface\r\n */\r\n\r\nvar assert = require('./chai/interface/assert');\r\nexports.use(assert);\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/assertion.js\", function(exports, require, module){\r\n/*!\r\n * chai\r\n * http://chaijs.com\r\n * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/*!\r\n * Module dependencies.\r\n */\r\n\r\nvar AssertionError = require('./error')\r\n  , util = require('./utils')\r\n  , flag = util.flag;\r\n\r\n/*!\r\n * Module export.\r\n */\r\n\r\nmodule.exports = Assertion;\r\n\r\n\r\n/*!\r\n * Assertion Constructor\r\n *\r\n * Creates object for chaining.\r\n *\r\n * @api private\r\n */\r\n\r\nfunction Assertion (obj, msg, stack) {\r\n  flag(this, 'ssfi', stack || arguments.callee);\r\n  flag(this, 'object', obj);\r\n  flag(this, 'message', msg);\r\n}\r\n\r\n/*!\r\n  * ### Assertion.includeStack\r\n  *\r\n  * User configurable property, influences whether stack trace\r\n  * is included in Assertion error message. Default of false\r\n  * suppresses stack trace in the error message\r\n  *\r\n  *     Assertion.includeStack = true;  // enable stack on error\r\n  *\r\n  * @api public\r\n  */\r\n\r\nAssertion.includeStack = false;\r\n\r\n/*!\r\n * ### Assertion.showDiff\r\n *\r\n * User configurable property, influences whether or not\r\n * the `showDiff` flag should be included in the thrown\r\n * AssertionErrors. `false` will always be `false`; `true`\r\n * will be true when the assertion has requested a diff\r\n * be shown.\r\n *\r\n * @api public\r\n */\r\n\r\nAssertion.showDiff = true;\r\n\r\nAssertion.addProperty = function (name, fn) {\r\n  util.addProperty(this.prototype, name, fn);\r\n};\r\n\r\nAssertion.addMethod = function (name, fn) {\r\n  util.addMethod(this.prototype, name, fn);\r\n};\r\n\r\nAssertion.addChainableMethod = function (name, fn, chainingBehavior) {\r\n  util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\r\n};\r\n\r\nAssertion.overwriteProperty = function (name, fn) {\r\n  util.overwriteProperty(this.prototype, name, fn);\r\n};\r\n\r\nAssertion.overwriteMethod = function (name, fn) {\r\n  util.overwriteMethod(this.prototype, name, fn);\r\n};\r\n\r\n/*!\r\n * ### .assert(expression, message, negateMessage, expected, actual)\r\n *\r\n * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\r\n *\r\n * @name assert\r\n * @param {Philosophical} expression to be tested\r\n * @param {String} message to display if fails\r\n * @param {String} negatedMessage to display if negated expression fails\r\n * @param {Mixed} expected value (remember to check for negation)\r\n * @param {Mixed} actual (optional) will default to `this.obj`\r\n * @api private\r\n */\r\n\r\nAssertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\r\n  var ok = util.test(this, arguments);\r\n  if (true !== showDiff) showDiff = false;\r\n  if (true !== Assertion.showDiff) showDiff = false;\r\n\r\n  if (!ok) {\r\n    var msg = util.getMessage(this, arguments)\r\n      , actual = util.getActual(this, arguments);\r\n    throw new AssertionError({\r\n        message: msg\r\n      , actual: actual\r\n      , expected: expected\r\n      , stackStartFunction: (Assertion.includeStack) ? this.assert : flag(this, 'ssfi')\r\n      , showDiff: showDiff\r\n    });\r\n  }\r\n};\r\n\r\n/*!\r\n * ### ._obj\r\n *\r\n * Quick reference to stored `actual` value for plugin developers.\r\n *\r\n * @api private\r\n */\r\n\r\nObject.defineProperty(Assertion.prototype, '_obj',\r\n  { get: function () {\r\n      return flag(this, 'object');\r\n    }\r\n  , set: function (val) {\r\n      flag(this, 'object', val);\r\n    }\r\n});\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/error.js\", function(exports, require, module){\r\n/*!\r\n * chai\r\n * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/*!\r\n * Main export\r\n */\r\n\r\nmodule.exports = AssertionError;\r\n\r\n/**\r\n * # AssertionError (constructor)\r\n *\r\n * Create a new assertion error based on the Javascript\r\n * `Error` prototype.\r\n *\r\n * **Options**\r\n * - message\r\n * - actual\r\n * - expected\r\n * - operator\r\n * - startStackFunction\r\n *\r\n * @param {Object} options\r\n * @api public\r\n */\r\n\r\nfunction AssertionError (options) {\r\n  options = options || {};\r\n  this.message = options.message;\r\n  this.actual = options.actual;\r\n  this.expected = options.expected;\r\n  this.operator = options.operator;\r\n  this.showDiff = options.showDiff;\r\n\r\n  if (options.stackStartFunction && Error.captureStackTrace) {\r\n    var stackStartFunction = options.stackStartFunction;\r\n    Error.captureStackTrace(this, stackStartFunction);\r\n  }\r\n}\r\n\r\n/*!\r\n * Inherit from Error\r\n */\r\n\r\nAssertionError.prototype = Object.create(Error.prototype);\r\nAssertionError.prototype.name = 'AssertionError';\r\nAssertionError.prototype.constructor = AssertionError;\r\n\r\n/**\r\n * # toString()\r\n *\r\n * Override default to string method\r\n */\r\n\r\nAssertionError.prototype.toString = function() {\r\n  return this.message;\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/core/assertions.js\", function(exports, require, module){\r\n/*!\r\n * chai\r\n * http://chaijs.com\r\n * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\nmodule.exports = function (chai, _) {\r\n  var Assertion = chai.Assertion\r\n    , toString = Object.prototype.toString\r\n    , flag = _.flag;\r\n\r\n  /**\r\n   * ### Language Chains\r\n   *\r\n   * The following are provide as chainable getters to\r\n   * improve the readability of your assertions. They\r\n   * do not provide an testing capability unless they\r\n   * have been overwritten by a plugin.\r\n   *\r\n   * **Chains**\r\n   *\r\n   * - to\r\n   * - be\r\n   * - been\r\n   * - is\r\n   * - that\r\n   * - and\r\n   * - have\r\n   * - with\r\n   * - at\r\n   * - of\r\n   * - same\r\n   *\r\n   * @name language chains\r\n   * @api public\r\n   */\r\n\r\n  [ 'to', 'be', 'been'\r\n  , 'is', 'and', 'have'\r\n  , 'with', 'that', 'at'\r\n  , 'of', 'same' ].forEach(function (chain) {\r\n    Assertion.addProperty(chain, function () {\r\n      return this;\r\n    });\r\n  });\r\n\r\n  /**\r\n   * ### .not\r\n   *\r\n   * Negates any of assertions following in the chain.\r\n   *\r\n   *     expect(foo).to.not.equal('bar');\r\n   *     expect(goodFn).to.not.throw(Error);\r\n   *     expect({ foo: 'baz' }).to.have.property('foo')\r\n   *       .and.not.equal('bar');\r\n   *\r\n   * @name not\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addProperty('not', function () {\r\n    flag(this, 'negate', true);\r\n  });\r\n\r\n  /**\r\n   * ### .deep\r\n   *\r\n   * Sets the `deep` flag, later used by the `equal` and\r\n   * `property` assertions.\r\n   *\r\n   *     expect(foo).to.deep.equal({ bar: 'baz' });\r\n   *     expect({ foo: { bar: { baz: 'quux' } } })\r\n   *       .to.have.deep.property('foo.bar.baz', 'quux');\r\n   *\r\n   * @name deep\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addProperty('deep', function () {\r\n    flag(this, 'deep', true);\r\n  });\r\n\r\n  /**\r\n   * ### .a(type)\r\n   *\r\n   * The `a` and `an` assertions are aliases that can be\r\n   * used either as language chains or to assert a value's\r\n   * type.\r\n   *\r\n   *     // typeof\r\n   *     expect('test').to.be.a('string');\r\n   *     expect({ foo: 'bar' }).to.be.an('object');\r\n   *     expect(null).to.be.a('null');\r\n   *     expect(undefined).to.be.an('undefined');\r\n   *\r\n   *     // language chain\r\n   *     expect(foo).to.be.an.instanceof(Foo);\r\n   *\r\n   * @name a\r\n   * @alias an\r\n   * @param {String} type\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  function an (type, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    type = type.toLowerCase();\r\n    var obj = flag(this, 'object')\r\n      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\r\n\r\n    this.assert(\r\n        type === _.type(obj)\r\n      , 'expected #{this} to be ' + article + type\r\n      , 'expected #{this} not to be ' + article + type\r\n    );\r\n  }\r\n\r\n  Assertion.addChainableMethod('an', an);\r\n  Assertion.addChainableMethod('a', an);\r\n\r\n  /**\r\n   * ### .include(value)\r\n   *\r\n   * The `include` and `contain` assertions can be used as either property\r\n   * based language chains or as methods to assert the inclusion of an object\r\n   * in an array or a substring in a string. When used as language chains,\r\n   * they toggle the `contain` flag for the `keys` assertion.\r\n   *\r\n   *     expect([1,2,3]).to.include(2);\r\n   *     expect('foobar').to.contain('foo');\r\n   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\r\n   *\r\n   * @name include\r\n   * @alias contain\r\n   * @param {Object|String|Number} obj\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  function includeChainingBehavior () {\r\n    flag(this, 'contains', true);\r\n  }\r\n\r\n  function include (val, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object')\r\n    this.assert(\r\n        ~obj.indexOf(val)\r\n      , 'expected #{this} to include ' + _.inspect(val)\r\n      , 'expected #{this} to not include ' + _.inspect(val));\r\n  }\r\n\r\n  Assertion.addChainableMethod('include', include, includeChainingBehavior);\r\n  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\r\n\r\n  /**\r\n   * ### .ok\r\n   *\r\n   * Asserts that the target is truthy.\r\n   *\r\n   *     expect('everthing').to.be.ok;\r\n   *     expect(1).to.be.ok;\r\n   *     expect(false).to.not.be.ok;\r\n   *     expect(undefined).to.not.be.ok;\r\n   *     expect(null).to.not.be.ok;\r\n   *\r\n   * @name ok\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addProperty('ok', function () {\r\n    this.assert(\r\n        flag(this, 'object')\r\n      , 'expected #{this} to be truthy'\r\n      , 'expected #{this} to be falsy');\r\n  });\r\n\r\n  /**\r\n   * ### .true\r\n   *\r\n   * Asserts that the target is `true`.\r\n   *\r\n   *     expect(true).to.be.true;\r\n   *     expect(1).to.not.be.true;\r\n   *\r\n   * @name true\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addProperty('true', function () {\r\n    this.assert(\r\n        true === flag(this, 'object')\r\n      , 'expected #{this} to be true'\r\n      , 'expected #{this} to be false'\r\n      , this.negate ? false : true\r\n    );\r\n  });\r\n\r\n  /**\r\n   * ### .false\r\n   *\r\n   * Asserts that the target is `false`.\r\n   *\r\n   *     expect(false).to.be.false;\r\n   *     expect(0).to.not.be.false;\r\n   *\r\n   * @name false\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addProperty('false', function () {\r\n    this.assert(\r\n        false === flag(this, 'object')\r\n      , 'expected #{this} to be false'\r\n      , 'expected #{this} to be true'\r\n      , this.negate ? true : false\r\n    );\r\n  });\r\n\r\n  /**\r\n   * ### .null\r\n   *\r\n   * Asserts that the target is `null`.\r\n   *\r\n   *     expect(null).to.be.null;\r\n   *     expect(undefined).not.to.be.null;\r\n   *\r\n   * @name null\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addProperty('null', function () {\r\n    this.assert(\r\n        null === flag(this, 'object')\r\n      , 'expected #{this} to be null'\r\n      , 'expected #{this} not to be null'\r\n    );\r\n  });\r\n\r\n  /**\r\n   * ### .undefined\r\n   *\r\n   * Asserts that the target is `undefined`.\r\n   *\r\n   *      expect(undefined).to.be.undefined;\r\n   *      expect(null).to.not.be.undefined;\r\n   *\r\n   * @name undefined\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addProperty('undefined', function () {\r\n    this.assert(\r\n        undefined === flag(this, 'object')\r\n      , 'expected #{this} to be undefined'\r\n      , 'expected #{this} not to be undefined'\r\n    );\r\n  });\r\n\r\n  /**\r\n   * ### .exist\r\n   *\r\n   * Asserts that the target is neither `null` nor `undefined`.\r\n   *\r\n   *     var foo = 'hi'\r\n   *       , bar = null\r\n   *       , baz;\r\n   *\r\n   *     expect(foo).to.exist;\r\n   *     expect(bar).to.not.exist;\r\n   *     expect(baz).to.not.exist;\r\n   *\r\n   * @name exist\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addProperty('exist', function () {\r\n    this.assert(\r\n        null != flag(this, 'object')\r\n      , 'expected #{this} to exist'\r\n      , 'expected #{this} to not exist'\r\n    );\r\n  });\r\n\r\n\r\n  /**\r\n   * ### .empty\r\n   *\r\n   * Asserts that the target's length is `0`. For arrays, it checks\r\n   * the `length` property. For objects, it gets the count of\r\n   * enumerable keys.\r\n   *\r\n   *     expect([]).to.be.empty;\r\n   *     expect('').to.be.empty;\r\n   *     expect({}).to.be.empty;\r\n   *\r\n   * @name empty\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addProperty('empty', function () {\r\n    var obj = flag(this, 'object')\r\n      , expected = obj;\r\n\r\n    if (Array.isArray(obj) || 'string' === typeof object) {\r\n      expected = obj.length;\r\n    } else if (typeof obj === 'object') {\r\n      expected = Object.keys(obj).length;\r\n    }\r\n\r\n    this.assert(\r\n        !expected\r\n      , 'expected #{this} to be empty'\r\n      , 'expected #{this} not to be empty'\r\n    );\r\n  });\r\n\r\n  /**\r\n   * ### .arguments\r\n   *\r\n   * Asserts that the target is an arguments object.\r\n   *\r\n   *     function test () {\r\n   *       expect(arguments).to.be.arguments;\r\n   *     }\r\n   *\r\n   * @name arguments\r\n   * @alias Arguments\r\n   * @api public\r\n   */\r\n\r\n  function checkArguments () {\r\n    var obj = flag(this, 'object')\r\n      , type = Object.prototype.toString.call(obj);\r\n    this.assert(\r\n        '[object Arguments]' === type\r\n      , 'expected #{this} to be arguments but got ' + type\r\n      , 'expected #{this} to not be arguments'\r\n    );\r\n  }\r\n\r\n  Assertion.addProperty('arguments', checkArguments);\r\n  Assertion.addProperty('Arguments', checkArguments);\r\n\r\n  /**\r\n   * ### .equal(value)\r\n   *\r\n   * Asserts that the target is strictly equal (`===`) to `value`.\r\n   * Alternately, if the `deep` flag is set, asserts that\r\n   * the target is deeply equal to `value`.\r\n   *\r\n   *     expect('hello').to.equal('hello');\r\n   *     expect(42).to.equal(42);\r\n   *     expect(1).to.not.equal(true);\r\n   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\r\n   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });\r\n   *\r\n   * @name equal\r\n   * @alias equals\r\n   * @alias eq\r\n   * @alias deep.equal\r\n   * @param {Mixed} value\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  function assertEqual (val, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    if (flag(this, 'deep')) {\r\n      return this.eql(val);\r\n    } else {\r\n      this.assert(\r\n          val === obj\r\n        , 'expected #{this} to equal #{exp}'\r\n        , 'expected #{this} to not equal #{exp}'\r\n        , val\r\n        , this._obj\r\n        , true\r\n      );\r\n    }\r\n  }\r\n\r\n  Assertion.addMethod('equal', assertEqual);\r\n  Assertion.addMethod('equals', assertEqual);\r\n  Assertion.addMethod('eq', assertEqual);\r\n\r\n  /**\r\n   * ### .eql(value)\r\n   *\r\n   * Asserts that the target is deeply equal to `value`.\r\n   *\r\n   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\r\n   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);\r\n   *\r\n   * @name eql\r\n   * @alias eqls\r\n   * @param {Mixed} value\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  function assertEql(obj, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    this.assert(\r\n        _.eql(obj, flag(this, 'object'))\r\n      , 'expected #{this} to deeply equal #{exp}'\r\n      , 'expected #{this} to not deeply equal #{exp}'\r\n      , obj\r\n      , this._obj\r\n      , true\r\n    );\r\n  }\r\n\r\n  Assertion.addMethod('eql', assertEql);\r\n  Assertion.addMethod('eqls', assertEql);\r\n\r\n  /**\r\n   * ### .above(value)\r\n   *\r\n   * Asserts that the target is greater than `value`.\r\n   *\r\n   *     expect(10).to.be.above(5);\r\n   *\r\n   * Can also be used in conjunction with `length` to\r\n   * assert a minimum length. The benefit being a\r\n   * more informative error message than if the length\r\n   * was supplied directly.\r\n   *\r\n   *     expect('foo').to.have.length.above(2);\r\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\r\n   *\r\n   * @name above\r\n   * @alias gt\r\n   * @alias greaterThan\r\n   * @param {Number} value\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  function assertAbove (n, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    if (flag(this, 'doLength')) {\r\n      new Assertion(obj, msg).to.have.property('length');\r\n      var len = obj.length;\r\n      this.assert(\r\n          len > n\r\n        , 'expected #{this} to have a length above #{exp} but got #{act}'\r\n        , 'expected #{this} to not have a length above #{exp}'\r\n        , n\r\n        , len\r\n      );\r\n    } else {\r\n      this.assert(\r\n          obj > n\r\n        , 'expected #{this} to be above ' + n\r\n        , 'expected #{this} to be at most ' + n\r\n      );\r\n    }\r\n  }\r\n\r\n  Assertion.addMethod('above', assertAbove);\r\n  Assertion.addMethod('gt', assertAbove);\r\n  Assertion.addMethod('greaterThan', assertAbove);\r\n\r\n  /**\r\n   * ### .least(value)\r\n   *\r\n   * Asserts that the target is greater than or equal to `value`.\r\n   *\r\n   *     expect(10).to.be.at.least(10);\r\n   *\r\n   * Can also be used in conjunction with `length` to\r\n   * assert a minimum length. The benefit being a\r\n   * more informative error message than if the length\r\n   * was supplied directly.\r\n   *\r\n   *     expect('foo').to.have.length.of.at.least(2);\r\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);\r\n   *\r\n   * @name least\r\n   * @alias gte\r\n   * @param {Number} value\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  function assertLeast (n, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    if (flag(this, 'doLength')) {\r\n      new Assertion(obj, msg).to.have.property('length');\r\n      var len = obj.length;\r\n      this.assert(\r\n          len >= n\r\n        , 'expected #{this} to have a length at least #{exp} but got #{act}'\r\n        , 'expected #{this} to have a length below #{exp}'\r\n        , n\r\n        , len\r\n      );\r\n    } else {\r\n      this.assert(\r\n          obj >= n\r\n        , 'expected #{this} to be at least ' + n\r\n        , 'expected #{this} to be below ' + n\r\n      );\r\n    }\r\n  }\r\n\r\n  Assertion.addMethod('least', assertLeast);\r\n  Assertion.addMethod('gte', assertLeast);\r\n\r\n  /**\r\n   * ### .below(value)\r\n   *\r\n   * Asserts that the target is less than `value`.\r\n   *\r\n   *     expect(5).to.be.below(10);\r\n   *\r\n   * Can also be used in conjunction with `length` to\r\n   * assert a maximum length. The benefit being a\r\n   * more informative error message than if the length\r\n   * was supplied directly.\r\n   *\r\n   *     expect('foo').to.have.length.below(4);\r\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\r\n   *\r\n   * @name below\r\n   * @alias lt\r\n   * @alias lessThan\r\n   * @param {Number} value\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  function assertBelow (n, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    if (flag(this, 'doLength')) {\r\n      new Assertion(obj, msg).to.have.property('length');\r\n      var len = obj.length;\r\n      this.assert(\r\n          len < n\r\n        , 'expected #{this} to have a length below #{exp} but got #{act}'\r\n        , 'expected #{this} to not have a length below #{exp}'\r\n        , n\r\n        , len\r\n      );\r\n    } else {\r\n      this.assert(\r\n          obj < n\r\n        , 'expected #{this} to be below ' + n\r\n        , 'expected #{this} to be at least ' + n\r\n      );\r\n    }\r\n  }\r\n\r\n  Assertion.addMethod('below', assertBelow);\r\n  Assertion.addMethod('lt', assertBelow);\r\n  Assertion.addMethod('lessThan', assertBelow);\r\n\r\n  /**\r\n   * ### .most(value)\r\n   *\r\n   * Asserts that the target is less than or equal to `value`.\r\n   *\r\n   *     expect(5).to.be.at.most(5);\r\n   *\r\n   * Can also be used in conjunction with `length` to\r\n   * assert a maximum length. The benefit being a\r\n   * more informative error message than if the length\r\n   * was supplied directly.\r\n   *\r\n   *     expect('foo').to.have.length.of.at.most(4);\r\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);\r\n   *\r\n   * @name most\r\n   * @alias lte\r\n   * @param {Number} value\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  function assertMost (n, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    if (flag(this, 'doLength')) {\r\n      new Assertion(obj, msg).to.have.property('length');\r\n      var len = obj.length;\r\n      this.assert(\r\n          len <= n\r\n        , 'expected #{this} to have a length at most #{exp} but got #{act}'\r\n        , 'expected #{this} to have a length above #{exp}'\r\n        , n\r\n        , len\r\n      );\r\n    } else {\r\n      this.assert(\r\n          obj <= n\r\n        , 'expected #{this} to be at most ' + n\r\n        , 'expected #{this} to be above ' + n\r\n      );\r\n    }\r\n  }\r\n\r\n  Assertion.addMethod('most', assertMost);\r\n  Assertion.addMethod('lte', assertMost);\r\n\r\n  /**\r\n   * ### .within(start, finish)\r\n   *\r\n   * Asserts that the target is within a range.\r\n   *\r\n   *     expect(7).to.be.within(5,10);\r\n   *\r\n   * Can also be used in conjunction with `length` to\r\n   * assert a length range. The benefit being a\r\n   * more informative error message than if the length\r\n   * was supplied directly.\r\n   *\r\n   *     expect('foo').to.have.length.within(2,4);\r\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\r\n   *\r\n   * @name within\r\n   * @param {Number} start lowerbound inclusive\r\n   * @param {Number} finish upperbound inclusive\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addMethod('within', function (start, finish, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object')\r\n      , range = start + '..' + finish;\r\n    if (flag(this, 'doLength')) {\r\n      new Assertion(obj, msg).to.have.property('length');\r\n      var len = obj.length;\r\n      this.assert(\r\n          len >= start && len <= finish\r\n        , 'expected #{this} to have a length within ' + range\r\n        , 'expected #{this} to not have a length within ' + range\r\n      );\r\n    } else {\r\n      this.assert(\r\n          obj >= start && obj <= finish\r\n        , 'expected #{this} to be within ' + range\r\n        , 'expected #{this} to not be within ' + range\r\n      );\r\n    }\r\n  });\r\n\r\n  /**\r\n   * ### .instanceof(constructor)\r\n   *\r\n   * Asserts that the target is an instance of `constructor`.\r\n   *\r\n   *     var Tea = function (name) { this.name = name; }\r\n   *       , Chai = new Tea('chai');\r\n   *\r\n   *     expect(Chai).to.be.an.instanceof(Tea);\r\n   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);\r\n   *\r\n   * @name instanceof\r\n   * @param {Constructor} constructor\r\n   * @param {String} message _optional_\r\n   * @alias instanceOf\r\n   * @api public\r\n   */\r\n\r\n  function assertInstanceOf (constructor, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var name = _.getName(constructor);\r\n    this.assert(\r\n        flag(this, 'object') instanceof constructor\r\n      , 'expected #{this} to be an instance of ' + name\r\n      , 'expected #{this} to not be an instance of ' + name\r\n    );\r\n  };\r\n\r\n  Assertion.addMethod('instanceof', assertInstanceOf);\r\n  Assertion.addMethod('instanceOf', assertInstanceOf);\r\n\r\n  /**\r\n   * ### .property(name, [value])\r\n   *\r\n   * Asserts that the target has a property `name`, optionally asserting that\r\n   * the value of that property is strictly equal to  `value`.\r\n   * If the `deep` flag is set, you can use dot- and bracket-notation for deep\r\n   * references into objects and arrays.\r\n   *\r\n   *     // simple referencing\r\n   *     var obj = { foo: 'bar' };\r\n   *     expect(obj).to.have.property('foo');\r\n   *     expect(obj).to.have.property('foo', 'bar');\r\n   *\r\n   *     // deep referencing\r\n   *     var deepObj = {\r\n   *         green: { tea: 'matcha' }\r\n   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\r\n   *     };\r\n\r\n   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');\r\n   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\r\n   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\r\n   *\r\n   * You can also use an array as the starting point of a `deep.property`\r\n   * assertion, or traverse nested arrays.\r\n   *\r\n   *     var arr = [\r\n   *         [ 'chai', 'matcha', 'konacha' ]\r\n   *       , [ { tea: 'chai' }\r\n   *         , { tea: 'matcha' }\r\n   *         , { tea: 'konacha' } ]\r\n   *     ];\r\n   *\r\n   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');\r\n   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\r\n   *\r\n   * Furthermore, `property` changes the subject of the assertion\r\n   * to be the value of that property from the original object. This\r\n   * permits for further chainable assertions on that property.\r\n   *\r\n   *     expect(obj).to.have.property('foo')\r\n   *       .that.is.a('string');\r\n   *     expect(deepObj).to.have.property('green')\r\n   *       .that.is.an('object')\r\n   *       .that.deep.equals({ tea: 'matcha' });\r\n   *     expect(deepObj).to.have.property('teas')\r\n   *       .that.is.an('array')\r\n   *       .with.deep.property('[2]')\r\n   *         .that.deep.equals({ tea: 'konacha' });\r\n   *\r\n   * @name property\r\n   * @alias deep.property\r\n   * @param {String} name\r\n   * @param {Mixed} value (optional)\r\n   * @param {String} message _optional_\r\n   * @returns value of property for chaining\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addMethod('property', function (name, val, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n\r\n    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '\r\n      , negate = flag(this, 'negate')\r\n      , obj = flag(this, 'object')\r\n      , value = flag(this, 'deep')\r\n        ? _.getPathValue(name, obj)\r\n        : obj[name];\r\n\r\n    if (negate && undefined !== val) {\r\n      if (undefined === value) {\r\n        msg = (msg != null) ? msg + ': ' : '';\r\n        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\r\n      }\r\n    } else {\r\n      this.assert(\r\n          undefined !== value\r\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name)\r\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\r\n    }\r\n\r\n    if (undefined !== val) {\r\n      this.assert(\r\n          val === value\r\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\r\n        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'\r\n        , val\r\n        , value\r\n      );\r\n    }\r\n\r\n    flag(this, 'object', value);\r\n  });\r\n\r\n\r\n  /**\r\n   * ### .ownProperty(name)\r\n   *\r\n   * Asserts that the target has an own property `name`.\r\n   *\r\n   *     expect('test').to.have.ownProperty('length');\r\n   *\r\n   * @name ownProperty\r\n   * @alias haveOwnProperty\r\n   * @param {String} name\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  function assertOwnProperty (name, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    this.assert(\r\n        obj.hasOwnProperty(name)\r\n      , 'expected #{this} to have own property ' + _.inspect(name)\r\n      , 'expected #{this} to not have own property ' + _.inspect(name)\r\n    );\r\n  }\r\n\r\n  Assertion.addMethod('ownProperty', assertOwnProperty);\r\n  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\r\n\r\n  /**\r\n   * ### .length(value)\r\n   *\r\n   * Asserts that the target's `length` property has\r\n   * the expected value.\r\n   *\r\n   *     expect([ 1, 2, 3]).to.have.length(3);\r\n   *     expect('foobar').to.have.length(6);\r\n   *\r\n   * Can also be used as a chain precursor to a value\r\n   * comparison for the length property.\r\n   *\r\n   *     expect('foo').to.have.length.above(2);\r\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\r\n   *     expect('foo').to.have.length.below(4);\r\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\r\n   *     expect('foo').to.have.length.within(2,4);\r\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\r\n   *\r\n   * @name length\r\n   * @alias lengthOf\r\n   * @param {Number} length\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  function assertLengthChain () {\r\n    flag(this, 'doLength', true);\r\n  }\r\n\r\n  function assertLength (n, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    new Assertion(obj, msg).to.have.property('length');\r\n    var len = obj.length;\r\n\r\n    this.assert(\r\n        len == n\r\n      , 'expected #{this} to have a length of #{exp} but got #{act}'\r\n      , 'expected #{this} to not have a length of #{act}'\r\n      , n\r\n      , len\r\n    );\r\n  }\r\n\r\n  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\r\n  Assertion.addMethod('lengthOf', assertLength, assertLengthChain);\r\n\r\n  /**\r\n   * ### .match(regexp)\r\n   *\r\n   * Asserts that the target matches a regular expression.\r\n   *\r\n   *     expect('foobar').to.match(/^foo/);\r\n   *\r\n   * @name match\r\n   * @param {RegExp} RegularExpression\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addMethod('match', function (re, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    this.assert(\r\n        re.exec(obj)\r\n      , 'expected #{this} to match ' + re\r\n      , 'expected #{this} not to match ' + re\r\n    );\r\n  });\r\n\r\n  /**\r\n   * ### .string(string)\r\n   *\r\n   * Asserts that the string target contains another string.\r\n   *\r\n   *     expect('foobar').to.have.string('bar');\r\n   *\r\n   * @name string\r\n   * @param {String} string\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addMethod('string', function (str, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    new Assertion(obj, msg).is.a('string');\r\n\r\n    this.assert(\r\n        ~obj.indexOf(str)\r\n      , 'expected #{this} to contain ' + _.inspect(str)\r\n      , 'expected #{this} to not contain ' + _.inspect(str)\r\n    );\r\n  });\r\n\r\n\r\n  /**\r\n   * ### .keys(key1, [key2], [...])\r\n   *\r\n   * Asserts that the target has exactly the given keys, or\r\n   * asserts the inclusion of some keys when using the\r\n   * `include` or `contain` modifiers.\r\n   *\r\n   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);\r\n   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');\r\n   *\r\n   * @name keys\r\n   * @alias key\r\n   * @param {String...|Array} keys\r\n   * @api public\r\n   */\r\n\r\n  function assertKeys (keys) {\r\n    var obj = flag(this, 'object')\r\n      , str\r\n      , ok = true;\r\n\r\n    keys = keys instanceof Array\r\n      ? keys\r\n      : Array.prototype.slice.call(arguments);\r\n\r\n    if (!keys.length) throw new Error('keys required');\r\n\r\n    var actual = Object.keys(obj)\r\n      , len = keys.length;\r\n\r\n    // Inclusion\r\n    ok = keys.every(function(key){\r\n      return ~actual.indexOf(key);\r\n    });\r\n\r\n    // Strict\r\n    if (!flag(this, 'negate') && !flag(this, 'contains')) {\r\n      ok = ok && keys.length == actual.length;\r\n    }\r\n\r\n    // Key string\r\n    if (len > 1) {\r\n      keys = keys.map(function(key){\r\n        return _.inspect(key);\r\n      });\r\n      var last = keys.pop();\r\n      str = keys.join(', ') + ', and ' + last;\r\n    } else {\r\n      str = _.inspect(keys[0]);\r\n    }\r\n\r\n    // Form\r\n    str = (len > 1 ? 'keys ' : 'key ') + str;\r\n\r\n    // Have / include\r\n    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\r\n\r\n    // Assertion\r\n    this.assert(\r\n        ok\r\n      , 'expected #{this} to ' + str\r\n      , 'expected #{this} to not ' + str\r\n    );\r\n  }\r\n\r\n  Assertion.addMethod('keys', assertKeys);\r\n  Assertion.addMethod('key', assertKeys);\r\n\r\n  /**\r\n   * ### .throw(constructor)\r\n   *\r\n   * Asserts that the function target will throw a specific error, or specific type of error\r\n   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test\r\n   * for the error's message.\r\n   *\r\n   *     var err = new ReferenceError('This is a bad function.');\r\n   *     var fn = function () { throw err; }\r\n   *     expect(fn).to.throw(ReferenceError);\r\n   *     expect(fn).to.throw(Error);\r\n   *     expect(fn).to.throw(/bad function/);\r\n   *     expect(fn).to.not.throw('good function');\r\n   *     expect(fn).to.throw(ReferenceError, /bad function/);\r\n   *     expect(fn).to.throw(err);\r\n   *     expect(fn).to.not.throw(new RangeError('Out of range.'));\r\n   *\r\n   * Please note that when a throw expectation is negated, it will check each\r\n   * parameter independently, starting with error constructor type. The appropriate way\r\n   * to check for the existence of a type of error but for a message that does not match\r\n   * is to use `and`.\r\n   *\r\n   *     expect(fn).to.throw(ReferenceError)\r\n   *        .and.not.throw(/good function/);\r\n   *\r\n   * @name throw\r\n   * @alias throws\r\n   * @alias Throw\r\n   * @param {ErrorConstructor} constructor\r\n   * @param {String|RegExp} expected error message\r\n   * @param {String} message _optional_\r\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\r\n   * @api public\r\n   */\r\n\r\n  function assertThrows (constructor, errMsg, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    new Assertion(obj, msg).is.a('function');\r\n\r\n    var thrown = false\r\n      , desiredError = null\r\n      , name = null\r\n      , thrownError = null;\r\n\r\n    if (arguments.length === 0) {\r\n      errMsg = null;\r\n      constructor = null;\r\n    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\r\n      errMsg = constructor;\r\n      constructor = null;\r\n    } else if (constructor && constructor instanceof Error) {\r\n      desiredError = constructor;\r\n      constructor = null;\r\n      errMsg = null;\r\n    } else if (typeof constructor === 'function') {\r\n      name = (new constructor()).name;\r\n    } else {\r\n      constructor = null;\r\n    }\r\n\r\n    try {\r\n      obj();\r\n    } catch (err) {\r\n      // first, check desired error\r\n      if (desiredError) {\r\n        this.assert(\r\n            err === desiredError\r\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\r\n          , 'expected #{this} to not throw #{exp}'\r\n          , desiredError\r\n          , err\r\n        );\r\n\r\n        return this;\r\n      }\r\n      // next, check constructor\r\n      if (constructor) {\r\n        this.assert(\r\n            err instanceof constructor\r\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\r\n          , 'expected #{this} to not throw #{exp} but #{act} was thrown'\r\n          , name\r\n          , err\r\n        );\r\n\r\n        if (!errMsg) return this;\r\n      }\r\n      // next, check message\r\n      var message = 'object' === _.type(err) && \"message\" in err\r\n        ? err.message\r\n        : '' + err;\r\n\r\n      if ((message != null) && errMsg && errMsg instanceof RegExp) {\r\n        this.assert(\r\n            errMsg.exec(message)\r\n          , 'expected #{this} to throw error matching #{exp} but got #{act}'\r\n          , 'expected #{this} to throw error not matching #{exp}'\r\n          , errMsg\r\n          , message\r\n        );\r\n\r\n        return this;\r\n      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {\r\n        this.assert(\r\n            ~message.indexOf(errMsg)\r\n          , 'expected #{this} to throw error including #{exp} but got #{act}'\r\n          , 'expected #{this} to throw error not including #{act}'\r\n          , errMsg\r\n          , message\r\n        );\r\n\r\n        return this;\r\n      } else {\r\n        thrown = true;\r\n        thrownError = err;\r\n      }\r\n    }\r\n\r\n    var actuallyGot = ''\r\n      , expectedThrown = name !== null\r\n        ? name\r\n        : desiredError\r\n          ? '#{exp}' //_.inspect(desiredError)\r\n          : 'an error';\r\n\r\n    if (thrown) {\r\n      actuallyGot = ' but #{act} was thrown'\r\n    }\r\n\r\n    this.assert(\r\n        thrown === true\r\n      , 'expected #{this} to throw ' + expectedThrown + actuallyGot\r\n      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot\r\n      , desiredError\r\n      , thrownError\r\n    );\r\n  };\r\n\r\n  Assertion.addMethod('throw', assertThrows);\r\n  Assertion.addMethod('throws', assertThrows);\r\n  Assertion.addMethod('Throw', assertThrows);\r\n\r\n  /**\r\n   * ### .respondTo(method)\r\n   *\r\n   * Asserts that the object or class target will respond to a method.\r\n   *\r\n   *     Klass.prototype.bar = function(){};\r\n   *     expect(Klass).to.respondTo('bar');\r\n   *     expect(obj).to.respondTo('bar');\r\n   *\r\n   * To check if a constructor will respond to a static function,\r\n   * set the `itself` flag.\r\n   *\r\n   *    Klass.baz = function(){};\r\n   *    expect(Klass).itself.to.respondTo('baz');\r\n   *\r\n   * @name respondTo\r\n   * @param {String} method\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addMethod('respondTo', function (method, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object')\r\n      , itself = flag(this, 'itself')\r\n      , context = ('function' === _.type(obj) && !itself)\r\n        ? obj.prototype[method]\r\n        : obj[method];\r\n\r\n    this.assert(\r\n        'function' === typeof context\r\n      , 'expected #{this} to respond to ' + _.inspect(method)\r\n      , 'expected #{this} to not respond to ' + _.inspect(method)\r\n    );\r\n  });\r\n\r\n  /**\r\n   * ### .itself\r\n   *\r\n   * Sets the `itself` flag, later used by the `respondTo` assertion.\r\n   *\r\n   *    function Foo() {}\r\n   *    Foo.bar = function() {}\r\n   *    Foo.prototype.baz = function() {}\r\n   *\r\n   *    expect(Foo).itself.to.respondTo('bar');\r\n   *    expect(Foo).itself.not.to.respondTo('baz');\r\n   *\r\n   * @name itself\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addProperty('itself', function () {\r\n    flag(this, 'itself', true);\r\n  });\r\n\r\n  /**\r\n   * ### .satisfy(method)\r\n   *\r\n   * Asserts that the target passes a given truth test.\r\n   *\r\n   *     expect(1).to.satisfy(function(num) { return num > 0; });\r\n   *\r\n   * @name satisfy\r\n   * @param {Function} matcher\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addMethod('satisfy', function (matcher, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    this.assert(\r\n        matcher(obj)\r\n      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\r\n      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\r\n      , this.negate ? false : true\r\n      , matcher(obj)\r\n    );\r\n  });\r\n\r\n  /**\r\n   * ### .closeTo(expected, delta)\r\n   *\r\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\r\n   *\r\n   *     expect(1.5).to.be.closeTo(1, 0.5);\r\n   *\r\n   * @name closeTo\r\n   * @param {Number} expected\r\n   * @param {Number} delta\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addMethod('closeTo', function (expected, delta, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n    this.assert(\r\n        Math.abs(obj - expected) <= delta\r\n      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\r\n      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\r\n    );\r\n  });\r\n\r\n  function isSubsetOf(subset, superset) {\r\n    return subset.every(function(elem) {\r\n      return superset.indexOf(elem) !== -1;\r\n    })\r\n  }\r\n\r\n  /**\r\n   * ### .members\r\n   *\r\n   * Asserts that the target is a superset of `set`,\r\n   * or that the target and `set` have the same members.\r\n   *\r\n   *    expect([1, 2, 3]).to.include.members([3, 2]);\r\n   *    expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\r\n   *\r\n   *    expect([4, 2]).to.have.members([2, 4]);\r\n   *    expect([5, 2]).to.not.have.members([5, 2, 1]);\r\n   *\r\n   * @name members\r\n   * @param {Array} set\r\n   * @param {String} message _optional_\r\n   * @api public\r\n   */\r\n\r\n  Assertion.addMethod('members', function (subset, msg) {\r\n    if (msg) flag(this, 'message', msg);\r\n    var obj = flag(this, 'object');\r\n\r\n    new Assertion(obj).to.be.an('array');\r\n    new Assertion(subset).to.be.an('array');\r\n\r\n    if (flag(this, 'contains')) {\r\n      return this.assert(\r\n          isSubsetOf(subset, obj)\r\n        , 'expected #{this} to be a superset of #{act}'\r\n        , 'expected #{this} to not be a superset of #{act}'\r\n        , obj\r\n        , subset\r\n      );\r\n    }\r\n\r\n    this.assert(\r\n        isSubsetOf(obj, subset) && isSubsetOf(subset, obj)\r\n        , 'expected #{this} to have the same members as #{act}'\r\n        , 'expected #{this} to not have the same members as #{act}'\r\n        , obj\r\n        , subset\r\n    );\r\n  });\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/interface/assert.js\", function(exports, require, module){\r\n/*!\r\n * chai\r\n * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n\r\nmodule.exports = function (chai, util) {\r\n\r\n  /*!\r\n   * Chai dependencies.\r\n   */\r\n\r\n  var Assertion = chai.Assertion\r\n    , flag = util.flag;\r\n\r\n  /*!\r\n   * Module export.\r\n   */\r\n\r\n  /**\r\n   * ### assert(expression, message)\r\n   *\r\n   * Write your own test expressions.\r\n   *\r\n   *     assert('foo' !== 'bar', 'foo is not bar');\r\n   *     assert(Array.isArray([]), 'empty arrays are arrays');\r\n   *\r\n   * @param {Mixed} expression to test for truthiness\r\n   * @param {String} message to display on error\r\n   * @name assert\r\n   * @api public\r\n   */\r\n\r\n  var assert = chai.assert = function (express, errmsg) {\r\n    var test = new Assertion(null);\r\n    test.assert(\r\n        express\r\n      , errmsg\r\n      , '[ negation message unavailable ]'\r\n    );\r\n  };\r\n\r\n  /**\r\n   * ### .fail(actual, expected, [message], [operator])\r\n   *\r\n   * Throw a failure. Node.js `assert` module-compatible.\r\n   *\r\n   * @name fail\r\n   * @param {Mixed} actual\r\n   * @param {Mixed} expected\r\n   * @param {String} message\r\n   * @param {String} operator\r\n   * @api public\r\n   */\r\n\r\n  assert.fail = function (actual, expected, message, operator) {\r\n    throw new chai.AssertionError({\r\n        actual: actual\r\n      , expected: expected\r\n      , message: message\r\n      , operator: operator\r\n      , stackStartFunction: assert.fail\r\n    });\r\n  };\r\n\r\n  /**\r\n   * ### .ok(object, [message])\r\n   *\r\n   * Asserts that `object` is truthy.\r\n   *\r\n   *     assert.ok('everything', 'everything is ok');\r\n   *     assert.ok(false, 'this will fail');\r\n   *\r\n   * @name ok\r\n   * @param {Mixed} object to test\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.ok = function (val, msg) {\r\n    new Assertion(val, msg).is.ok;\r\n  };\r\n\r\n  /**\r\n   * ### .equal(actual, expected, [message])\r\n   *\r\n   * Asserts non-strict equality (`==`) of `actual` and `expected`.\r\n   *\r\n   *     assert.equal(3, '3', '== coerces values to strings');\r\n   *\r\n   * @name equal\r\n   * @param {Mixed} actual\r\n   * @param {Mixed} expected\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.equal = function (act, exp, msg) {\r\n    var test = new Assertion(act, msg);\r\n\r\n    test.assert(\r\n        exp == flag(test, 'object')\r\n      , 'expected #{this} to equal #{exp}'\r\n      , 'expected #{this} to not equal #{act}'\r\n      , exp\r\n      , act\r\n    );\r\n  };\r\n\r\n  /**\r\n   * ### .notEqual(actual, expected, [message])\r\n   *\r\n   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\r\n   *\r\n   *     assert.notEqual(3, 4, 'these numbers are not equal');\r\n   *\r\n   * @name notEqual\r\n   * @param {Mixed} actual\r\n   * @param {Mixed} expected\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.notEqual = function (act, exp, msg) {\r\n    var test = new Assertion(act, msg);\r\n\r\n    test.assert(\r\n        exp != flag(test, 'object')\r\n      , 'expected #{this} to not equal #{exp}'\r\n      , 'expected #{this} to equal #{act}'\r\n      , exp\r\n      , act\r\n    );\r\n  };\r\n\r\n  /**\r\n   * ### .strictEqual(actual, expected, [message])\r\n   *\r\n   * Asserts strict equality (`===`) of `actual` and `expected`.\r\n   *\r\n   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\r\n   *\r\n   * @name strictEqual\r\n   * @param {Mixed} actual\r\n   * @param {Mixed} expected\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.strictEqual = function (act, exp, msg) {\r\n    new Assertion(act, msg).to.equal(exp);\r\n  };\r\n\r\n  /**\r\n   * ### .notStrictEqual(actual, expected, [message])\r\n   *\r\n   * Asserts strict inequality (`!==`) of `actual` and `expected`.\r\n   *\r\n   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\r\n   *\r\n   * @name notStrictEqual\r\n   * @param {Mixed} actual\r\n   * @param {Mixed} expected\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.notStrictEqual = function (act, exp, msg) {\r\n    new Assertion(act, msg).to.not.equal(exp);\r\n  };\r\n\r\n  /**\r\n   * ### .deepEqual(actual, expected, [message])\r\n   *\r\n   * Asserts that `actual` is deeply equal to `expected`.\r\n   *\r\n   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\r\n   *\r\n   * @name deepEqual\r\n   * @param {Mixed} actual\r\n   * @param {Mixed} expected\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.deepEqual = function (act, exp, msg) {\r\n    new Assertion(act, msg).to.eql(exp);\r\n  };\r\n\r\n  /**\r\n   * ### .notDeepEqual(actual, expected, [message])\r\n   *\r\n   * Assert that `actual` is not deeply equal to `expected`.\r\n   *\r\n   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\r\n   *\r\n   * @name notDeepEqual\r\n   * @param {Mixed} actual\r\n   * @param {Mixed} expected\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.notDeepEqual = function (act, exp, msg) {\r\n    new Assertion(act, msg).to.not.eql(exp);\r\n  };\r\n\r\n  /**\r\n   * ### .isTrue(value, [message])\r\n   *\r\n   * Asserts that `value` is true.\r\n   *\r\n   *     var teaServed = true;\r\n   *     assert.isTrue(teaServed, 'the tea has been served');\r\n   *\r\n   * @name isTrue\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isTrue = function (val, msg) {\r\n    new Assertion(val, msg).is['true'];\r\n  };\r\n\r\n  /**\r\n   * ### .isFalse(value, [message])\r\n   *\r\n   * Asserts that `value` is false.\r\n   *\r\n   *     var teaServed = false;\r\n   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\r\n   *\r\n   * @name isFalse\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isFalse = function (val, msg) {\r\n    new Assertion(val, msg).is['false'];\r\n  };\r\n\r\n  /**\r\n   * ### .isNull(value, [message])\r\n   *\r\n   * Asserts that `value` is null.\r\n   *\r\n   *     assert.isNull(err, 'there was no error');\r\n   *\r\n   * @name isNull\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isNull = function (val, msg) {\r\n    new Assertion(val, msg).to.equal(null);\r\n  };\r\n\r\n  /**\r\n   * ### .isNotNull(value, [message])\r\n   *\r\n   * Asserts that `value` is not null.\r\n   *\r\n   *     var tea = 'tasty chai';\r\n   *     assert.isNotNull(tea, 'great, time for tea!');\r\n   *\r\n   * @name isNotNull\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isNotNull = function (val, msg) {\r\n    new Assertion(val, msg).to.not.equal(null);\r\n  };\r\n\r\n  /**\r\n   * ### .isUndefined(value, [message])\r\n   *\r\n   * Asserts that `value` is `undefined`.\r\n   *\r\n   *     var tea;\r\n   *     assert.isUndefined(tea, 'no tea defined');\r\n   *\r\n   * @name isUndefined\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isUndefined = function (val, msg) {\r\n    new Assertion(val, msg).to.equal(undefined);\r\n  };\r\n\r\n  /**\r\n   * ### .isDefined(value, [message])\r\n   *\r\n   * Asserts that `value` is not `undefined`.\r\n   *\r\n   *     var tea = 'cup of chai';\r\n   *     assert.isDefined(tea, 'tea has been defined');\r\n   *\r\n   * @name isUndefined\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isDefined = function (val, msg) {\r\n    new Assertion(val, msg).to.not.equal(undefined);\r\n  };\r\n\r\n  /**\r\n   * ### .isFunction(value, [message])\r\n   *\r\n   * Asserts that `value` is a function.\r\n   *\r\n   *     function serveTea() { return 'cup of tea'; };\r\n   *     assert.isFunction(serveTea, 'great, we can have tea now');\r\n   *\r\n   * @name isFunction\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isFunction = function (val, msg) {\r\n    new Assertion(val, msg).to.be.a('function');\r\n  };\r\n\r\n  /**\r\n   * ### .isNotFunction(value, [message])\r\n   *\r\n   * Asserts that `value` is _not_ a function.\r\n   *\r\n   *     var serveTea = [ 'heat', 'pour', 'sip' ];\r\n   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\r\n   *\r\n   * @name isNotFunction\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isNotFunction = function (val, msg) {\r\n    new Assertion(val, msg).to.not.be.a('function');\r\n  };\r\n\r\n  /**\r\n   * ### .isObject(value, [message])\r\n   *\r\n   * Asserts that `value` is an object (as revealed by\r\n   * `Object.prototype.toString`).\r\n   *\r\n   *     var selection = { name: 'Chai', serve: 'with spices' };\r\n   *     assert.isObject(selection, 'tea selection is an object');\r\n   *\r\n   * @name isObject\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isObject = function (val, msg) {\r\n    new Assertion(val, msg).to.be.a('object');\r\n  };\r\n\r\n  /**\r\n   * ### .isNotObject(value, [message])\r\n   *\r\n   * Asserts that `value` is _not_ an object.\r\n   *\r\n   *     var selection = 'chai'\r\n   *     assert.isObject(selection, 'tea selection is not an object');\r\n   *     assert.isObject(null, 'null is not an object');\r\n   *\r\n   * @name isNotObject\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isNotObject = function (val, msg) {\r\n    new Assertion(val, msg).to.not.be.a('object');\r\n  };\r\n\r\n  /**\r\n   * ### .isArray(value, [message])\r\n   *\r\n   * Asserts that `value` is an array.\r\n   *\r\n   *     var menu = [ 'green', 'chai', 'oolong' ];\r\n   *     assert.isArray(menu, 'what kind of tea do we want?');\r\n   *\r\n   * @name isArray\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isArray = function (val, msg) {\r\n    new Assertion(val, msg).to.be.an('array');\r\n  };\r\n\r\n  /**\r\n   * ### .isNotArray(value, [message])\r\n   *\r\n   * Asserts that `value` is _not_ an array.\r\n   *\r\n   *     var menu = 'green|chai|oolong';\r\n   *     assert.isNotArray(menu, 'what kind of tea do we want?');\r\n   *\r\n   * @name isNotArray\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isNotArray = function (val, msg) {\r\n    new Assertion(val, msg).to.not.be.an('array');\r\n  };\r\n\r\n  /**\r\n   * ### .isString(value, [message])\r\n   *\r\n   * Asserts that `value` is a string.\r\n   *\r\n   *     var teaOrder = 'chai';\r\n   *     assert.isString(teaOrder, 'order placed');\r\n   *\r\n   * @name isString\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isString = function (val, msg) {\r\n    new Assertion(val, msg).to.be.a('string');\r\n  };\r\n\r\n  /**\r\n   * ### .isNotString(value, [message])\r\n   *\r\n   * Asserts that `value` is _not_ a string.\r\n   *\r\n   *     var teaOrder = 4;\r\n   *     assert.isNotString(teaOrder, 'order placed');\r\n   *\r\n   * @name isNotString\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isNotString = function (val, msg) {\r\n    new Assertion(val, msg).to.not.be.a('string');\r\n  };\r\n\r\n  /**\r\n   * ### .isNumber(value, [message])\r\n   *\r\n   * Asserts that `value` is a number.\r\n   *\r\n   *     var cups = 2;\r\n   *     assert.isNumber(cups, 'how many cups');\r\n   *\r\n   * @name isNumber\r\n   * @param {Number} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isNumber = function (val, msg) {\r\n    new Assertion(val, msg).to.be.a('number');\r\n  };\r\n\r\n  /**\r\n   * ### .isNotNumber(value, [message])\r\n   *\r\n   * Asserts that `value` is _not_ a number.\r\n   *\r\n   *     var cups = '2 cups please';\r\n   *     assert.isNotNumber(cups, 'how many cups');\r\n   *\r\n   * @name isNotNumber\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isNotNumber = function (val, msg) {\r\n    new Assertion(val, msg).to.not.be.a('number');\r\n  };\r\n\r\n  /**\r\n   * ### .isBoolean(value, [message])\r\n   *\r\n   * Asserts that `value` is a boolean.\r\n   *\r\n   *     var teaReady = true\r\n   *       , teaServed = false;\r\n   *\r\n   *     assert.isBoolean(teaReady, 'is the tea ready');\r\n   *     assert.isBoolean(teaServed, 'has tea been served');\r\n   *\r\n   * @name isBoolean\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isBoolean = function (val, msg) {\r\n    new Assertion(val, msg).to.be.a('boolean');\r\n  };\r\n\r\n  /**\r\n   * ### .isNotBoolean(value, [message])\r\n   *\r\n   * Asserts that `value` is _not_ a boolean.\r\n   *\r\n   *     var teaReady = 'yep'\r\n   *       , teaServed = 'nope';\r\n   *\r\n   *     assert.isNotBoolean(teaReady, 'is the tea ready');\r\n   *     assert.isNotBoolean(teaServed, 'has tea been served');\r\n   *\r\n   * @name isNotBoolean\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.isNotBoolean = function (val, msg) {\r\n    new Assertion(val, msg).to.not.be.a('boolean');\r\n  };\r\n\r\n  /**\r\n   * ### .typeOf(value, name, [message])\r\n   *\r\n   * Asserts that `value`'s type is `name`, as determined by\r\n   * `Object.prototype.toString`.\r\n   *\r\n   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\r\n   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\r\n   *     assert.typeOf('tea', 'string', 'we have a string');\r\n   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\r\n   *     assert.typeOf(null, 'null', 'we have a null');\r\n   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\r\n   *\r\n   * @name typeOf\r\n   * @param {Mixed} value\r\n   * @param {String} name\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.typeOf = function (val, type, msg) {\r\n    new Assertion(val, msg).to.be.a(type);\r\n  };\r\n\r\n  /**\r\n   * ### .notTypeOf(value, name, [message])\r\n   *\r\n   * Asserts that `value`'s type is _not_ `name`, as determined by\r\n   * `Object.prototype.toString`.\r\n   *\r\n   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\r\n   *\r\n   * @name notTypeOf\r\n   * @param {Mixed} value\r\n   * @param {String} typeof name\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.notTypeOf = function (val, type, msg) {\r\n    new Assertion(val, msg).to.not.be.a(type);\r\n  };\r\n\r\n  /**\r\n   * ### .instanceOf(object, constructor, [message])\r\n   *\r\n   * Asserts that `value` is an instance of `constructor`.\r\n   *\r\n   *     var Tea = function (name) { this.name = name; }\r\n   *       , chai = new Tea('chai');\r\n   *\r\n   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\r\n   *\r\n   * @name instanceOf\r\n   * @param {Object} object\r\n   * @param {Constructor} constructor\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.instanceOf = function (val, type, msg) {\r\n    new Assertion(val, msg).to.be.instanceOf(type);\r\n  };\r\n\r\n  /**\r\n   * ### .notInstanceOf(object, constructor, [message])\r\n   *\r\n   * Asserts `value` is not an instance of `constructor`.\r\n   *\r\n   *     var Tea = function (name) { this.name = name; }\r\n   *       , chai = new String('chai');\r\n   *\r\n   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\r\n   *\r\n   * @name notInstanceOf\r\n   * @param {Object} object\r\n   * @param {Constructor} constructor\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.notInstanceOf = function (val, type, msg) {\r\n    new Assertion(val, msg).to.not.be.instanceOf(type);\r\n  };\r\n\r\n  /**\r\n   * ### .include(haystack, needle, [message])\r\n   *\r\n   * Asserts that `haystack` includes `needle`. Works\r\n   * for strings and arrays.\r\n   *\r\n   *     assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\r\n   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');\r\n   *\r\n   * @name include\r\n   * @param {Array|String} haystack\r\n   * @param {Mixed} needle\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.include = function (exp, inc, msg) {\r\n    var obj = new Assertion(exp, msg);\r\n\r\n    if (Array.isArray(exp)) {\r\n      obj.to.include(inc);\r\n    } else if ('string' === typeof exp) {\r\n      obj.to.contain.string(inc);\r\n    } else {\r\n      throw new chai.AssertionError({\r\n          message: 'expected an array or string'\r\n        , stackStartFunction: assert.include\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * ### .notInclude(haystack, needle, [message])\r\n   *\r\n   * Asserts that `haystack` does not include `needle`. Works\r\n   * for strings and arrays.\r\n   *i\r\n   *     assert.notInclude('foobar', 'baz', 'string not include substring');\r\n   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');\r\n   *\r\n   * @name notInclude\r\n   * @param {Array|String} haystack\r\n   * @param {Mixed} needle\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.notInclude = function (exp, inc, msg) {\r\n    var obj = new Assertion(exp, msg);\r\n\r\n    if (Array.isArray(exp)) {\r\n      obj.to.not.include(inc);\r\n    } else if ('string' === typeof exp) {\r\n      obj.to.not.contain.string(inc);\r\n    } else {\r\n      throw new chai.AssertionError({\r\n          message: 'expected an array or string'\r\n        , stackStartFunction: assert.include\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * ### .match(value, regexp, [message])\r\n   *\r\n   * Asserts that `value` matches the regular expression `regexp`.\r\n   *\r\n   *     assert.match('foobar', /^foo/, 'regexp matches');\r\n   *\r\n   * @name match\r\n   * @param {Mixed} value\r\n   * @param {RegExp} regexp\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.match = function (exp, re, msg) {\r\n    new Assertion(exp, msg).to.match(re);\r\n  };\r\n\r\n  /**\r\n   * ### .notMatch(value, regexp, [message])\r\n   *\r\n   * Asserts that `value` does not match the regular expression `regexp`.\r\n   *\r\n   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\r\n   *\r\n   * @name notMatch\r\n   * @param {Mixed} value\r\n   * @param {RegExp} regexp\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.notMatch = function (exp, re, msg) {\r\n    new Assertion(exp, msg).to.not.match(re);\r\n  };\r\n\r\n  /**\r\n   * ### .property(object, property, [message])\r\n   *\r\n   * Asserts that `object` has a property named by `property`.\r\n   *\r\n   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\r\n   *\r\n   * @name property\r\n   * @param {Object} object\r\n   * @param {String} property\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.property = function (obj, prop, msg) {\r\n    new Assertion(obj, msg).to.have.property(prop);\r\n  };\r\n\r\n  /**\r\n   * ### .notProperty(object, property, [message])\r\n   *\r\n   * Asserts that `object` does _not_ have a property named by `property`.\r\n   *\r\n   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\r\n   *\r\n   * @name notProperty\r\n   * @param {Object} object\r\n   * @param {String} property\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.notProperty = function (obj, prop, msg) {\r\n    new Assertion(obj, msg).to.not.have.property(prop);\r\n  };\r\n\r\n  /**\r\n   * ### .deepProperty(object, property, [message])\r\n   *\r\n   * Asserts that `object` has a property named by `property`, which can be a\r\n   * string using dot- and bracket-notation for deep reference.\r\n   *\r\n   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');\r\n   *\r\n   * @name deepProperty\r\n   * @param {Object} object\r\n   * @param {String} property\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.deepProperty = function (obj, prop, msg) {\r\n    new Assertion(obj, msg).to.have.deep.property(prop);\r\n  };\r\n\r\n  /**\r\n   * ### .notDeepProperty(object, property, [message])\r\n   *\r\n   * Asserts that `object` does _not_ have a property named by `property`, which\r\n   * can be a string using dot- and bracket-notation for deep reference.\r\n   *\r\n   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\r\n   *\r\n   * @name notDeepProperty\r\n   * @param {Object} object\r\n   * @param {String} property\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.notDeepProperty = function (obj, prop, msg) {\r\n    new Assertion(obj, msg).to.not.have.deep.property(prop);\r\n  };\r\n\r\n  /**\r\n   * ### .propertyVal(object, property, value, [message])\r\n   *\r\n   * Asserts that `object` has a property named by `property` with value given\r\n   * by `value`.\r\n   *\r\n   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\r\n   *\r\n   * @name propertyVal\r\n   * @param {Object} object\r\n   * @param {String} property\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.propertyVal = function (obj, prop, val, msg) {\r\n    new Assertion(obj, msg).to.have.property(prop, val);\r\n  };\r\n\r\n  /**\r\n   * ### .propertyNotVal(object, property, value, [message])\r\n   *\r\n   * Asserts that `object` has a property named by `property`, but with a value\r\n   * different from that given by `value`.\r\n   *\r\n   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');\r\n   *\r\n   * @name propertyNotVal\r\n   * @param {Object} object\r\n   * @param {String} property\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.propertyNotVal = function (obj, prop, val, msg) {\r\n    new Assertion(obj, msg).to.not.have.property(prop, val);\r\n  };\r\n\r\n  /**\r\n   * ### .deepPropertyVal(object, property, value, [message])\r\n   *\r\n   * Asserts that `object` has a property named by `property` with value given\r\n   * by `value`. `property` can use dot- and bracket-notation for deep\r\n   * reference.\r\n   *\r\n   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\r\n   *\r\n   * @name deepPropertyVal\r\n   * @param {Object} object\r\n   * @param {String} property\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.deepPropertyVal = function (obj, prop, val, msg) {\r\n    new Assertion(obj, msg).to.have.deep.property(prop, val);\r\n  };\r\n\r\n  /**\r\n   * ### .deepPropertyNotVal(object, property, value, [message])\r\n   *\r\n   * Asserts that `object` has a property named by `property`, but with a value\r\n   * different from that given by `value`. `property` can use dot- and\r\n   * bracket-notation for deep reference.\r\n   *\r\n   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\r\n   *\r\n   * @name deepPropertyNotVal\r\n   * @param {Object} object\r\n   * @param {String} property\r\n   * @param {Mixed} value\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.deepPropertyNotVal = function (obj, prop, val, msg) {\r\n    new Assertion(obj, msg).to.not.have.deep.property(prop, val);\r\n  };\r\n\r\n  /**\r\n   * ### .lengthOf(object, length, [message])\r\n   *\r\n   * Asserts that `object` has a `length` property with the expected value.\r\n   *\r\n   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\r\n   *     assert.lengthOf('foobar', 5, 'string has length of 6');\r\n   *\r\n   * @name lengthOf\r\n   * @param {Mixed} object\r\n   * @param {Number} length\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.lengthOf = function (exp, len, msg) {\r\n    new Assertion(exp, msg).to.have.length(len);\r\n  };\r\n\r\n  /**\r\n   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])\r\n   *\r\n   * Asserts that `function` will throw an error that is an instance of\r\n   * `constructor`, or alternately that it will throw an error with message\r\n   * matching `regexp`.\r\n   *\r\n   *     assert.throw(fn, 'function throws a reference error');\r\n   *     assert.throw(fn, /function throws a reference error/);\r\n   *     assert.throw(fn, ReferenceError);\r\n   *     assert.throw(fn, ReferenceError, 'function throws a reference error');\r\n   *     assert.throw(fn, ReferenceError, /function throws a reference error/);\r\n   *\r\n   * @name throws\r\n   * @alias throw\r\n   * @alias Throw\r\n   * @param {Function} function\r\n   * @param {ErrorConstructor} constructor\r\n   * @param {RegExp} regexp\r\n   * @param {String} message\r\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\r\n   * @api public\r\n   */\r\n\r\n  assert.Throw = function (fn, errt, errs, msg) {\r\n    if ('string' === typeof errt || errt instanceof RegExp) {\r\n      errs = errt;\r\n      errt = null;\r\n    }\r\n\r\n    new Assertion(fn, msg).to.Throw(errt, errs);\r\n  };\r\n\r\n  /**\r\n   * ### .doesNotThrow(function, [constructor/regexp], [message])\r\n   *\r\n   * Asserts that `function` will _not_ throw an error that is an instance of\r\n   * `constructor`, or alternately that it will not throw an error with message\r\n   * matching `regexp`.\r\n   *\r\n   *     assert.doesNotThrow(fn, Error, 'function does not throw');\r\n   *\r\n   * @name doesNotThrow\r\n   * @param {Function} function\r\n   * @param {ErrorConstructor} constructor\r\n   * @param {RegExp} regexp\r\n   * @param {String} message\r\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\r\n   * @api public\r\n   */\r\n\r\n  assert.doesNotThrow = function (fn, type, msg) {\r\n    if ('string' === typeof type) {\r\n      msg = type;\r\n      type = null;\r\n    }\r\n\r\n    new Assertion(fn, msg).to.not.Throw(type);\r\n  };\r\n\r\n  /**\r\n   * ### .operator(val1, operator, val2, [message])\r\n   *\r\n   * Compares two values using `operator`.\r\n   *\r\n   *     assert.operator(1, '<', 2, 'everything is ok');\r\n   *     assert.operator(1, '>', 2, 'this will fail');\r\n   *\r\n   * @name operator\r\n   * @param {Mixed} val1\r\n   * @param {String} operator\r\n   * @param {Mixed} val2\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.operator = function (val, operator, val2, msg) {\r\n    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {\r\n      throw new Error('Invalid operator \"' + operator + '\"');\r\n    }\r\n    var test = new Assertion(eval(val + operator + val2), msg);\r\n    test.assert(\r\n        true === flag(test, 'object')\r\n      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\r\n      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\r\n  };\r\n\r\n  /**\r\n   * ### .closeTo(actual, expected, delta, [message])\r\n   *\r\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\r\n   *\r\n   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\r\n   *\r\n   * @name closeTo\r\n   * @param {Number} actual\r\n   * @param {Number} expected\r\n   * @param {Number} delta\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.closeTo = function (act, exp, delta, msg) {\r\n    new Assertion(act, msg).to.be.closeTo(exp, delta);\r\n  };\r\n\r\n  /**\r\n   * ### .sameMembers(set1, set2, [message])\r\n   *\r\n   * Asserts that `set1` and `set2` have the same members.\r\n   * Order is not taken into account.\r\n   *\r\n   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\r\n   *\r\n   * @name sameMembers\r\n   * @param {Array} superset\r\n   * @param {Array} subset\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.sameMembers = function (set1, set2, msg) {\r\n    new Assertion(set1, msg).to.have.same.members(set2);\r\n  }\r\n\r\n  /**\r\n   * ### .includeMembers(superset, subset, [message])\r\n   *\r\n   * Asserts that `subset` is included in `superset`.\r\n   * Order is not taken into account.\r\n   *\r\n   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');\r\n   *\r\n   * @name includeMembers\r\n   * @param {Array} superset\r\n   * @param {Array} subset\r\n   * @param {String} message\r\n   * @api public\r\n   */\r\n\r\n  assert.includeMembers = function (superset, subset, msg) {\r\n    new Assertion(superset, msg).to.include.members(subset);\r\n  }\r\n\r\n  /*!\r\n   * Undocumented / untested\r\n   */\r\n\r\n  assert.ifError = function (val, msg) {\r\n    new Assertion(val, msg).to.not.be.ok;\r\n  };\r\n\r\n  /*!\r\n   * Aliases.\r\n   */\r\n\r\n  (function alias(name, as){\r\n    assert[as] = assert[name];\r\n    return alias;\r\n  })\r\n  ('Throw', 'throw')\r\n  ('Throw', 'throws');\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/interface/expect.js\", function(exports, require, module){\r\n/*!\r\n * chai\r\n * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\nmodule.exports = function (chai, util) {\r\n  chai.expect = function (val, message) {\r\n    return new chai.Assertion(val, message);\r\n  };\r\n};\r\n\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/interface/should.js\", function(exports, require, module){\r\n/*!\r\n * chai\r\n * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\nmodule.exports = function (chai, util) {\r\n  var Assertion = chai.Assertion;\r\n\r\n  function loadShould () {\r\n    // modify Object.prototype to have `should`\r\n    Object.defineProperty(Object.prototype, 'should',\r\n      {\r\n        set: function (value) {\r\n          // See https://github.com/chaijs/chai/issues/86: this makes\r\n          // `whatever.should = someValue` actually set `someValue`, which is\r\n          // especially useful for `global.should = require('chai').should()`.\r\n          //\r\n          // Note that we have to use [[DefineProperty]] instead of [[Put]]\r\n          // since otherwise we would trigger this very setter!\r\n          Object.defineProperty(this, 'should', {\r\n            value: value,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true\r\n          });\r\n        }\r\n      , get: function(){\r\n          if (this instanceof String || this instanceof Number) {\r\n            return new Assertion(this.constructor(this));\r\n          } else if (this instanceof Boolean) {\r\n            return new Assertion(this == true);\r\n          }\r\n          return new Assertion(this);\r\n        }\r\n      , configurable: true\r\n    });\r\n\r\n    var should = {};\r\n\r\n    should.equal = function (val1, val2, msg) {\r\n      new Assertion(val1, msg).to.equal(val2);\r\n    };\r\n\r\n    should.Throw = function (fn, errt, errs, msg) {\r\n      new Assertion(fn, msg).to.Throw(errt, errs);\r\n    };\r\n\r\n    should.exist = function (val, msg) {\r\n      new Assertion(val, msg).to.exist;\r\n    }\r\n\r\n    // negation\r\n    should.not = {}\r\n\r\n    should.not.equal = function (val1, val2, msg) {\r\n      new Assertion(val1, msg).to.not.equal(val2);\r\n    };\r\n\r\n    should.not.Throw = function (fn, errt, errs, msg) {\r\n      new Assertion(fn, msg).to.not.Throw(errt, errs);\r\n    };\r\n\r\n    should.not.exist = function (val, msg) {\r\n      new Assertion(val, msg).to.not.exist;\r\n    }\r\n\r\n    should['throw'] = should['Throw'];\r\n    should.not['throw'] = should.not['Throw'];\r\n\r\n    return should;\r\n  };\r\n\r\n  chai.should = loadShould;\r\n  chai.Should = loadShould;\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/addChainableMethod.js\", function(exports, require, module){\r\n/*!\r\n * Chai - addChainingMethod utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/*!\r\n * Module dependencies\r\n */\r\n\r\nvar transferFlags = require('./transferFlags');\r\n\r\n/*!\r\n * Module variables\r\n */\r\n\r\n// Check whether `__proto__` is supported\r\nvar hasProtoSupport = '__proto__' in Object;\r\n\r\n// Without `__proto__` support, this module will need to add properties to a function.\r\n// However, some Function.prototype methods cannot be overwritten,\r\n// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\r\nvar excludeNames = /^(?:length|name|arguments|caller)$/;\r\n\r\n// Cache `Function` properties\r\nvar call  = Function.prototype.call,\r\n    apply = Function.prototype.apply;\r\n\r\n/**\r\n * ### addChainableMethod (ctx, name, method, chainingBehavior)\r\n *\r\n * Adds a method to an object, such that the method can also be chained.\r\n *\r\n *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\r\n *       var obj = utils.flag(this, 'object');\r\n *       new chai.Assertion(obj).to.be.equal(str);\r\n *     });\r\n *\r\n * Can also be accessed directly from `chai.Assertion`.\r\n *\r\n *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\r\n *\r\n * The result can then be used as both a method assertion, executing both `method` and\r\n * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\r\n *\r\n *     expect(fooStr).to.be.foo('bar');\r\n *     expect(fooStr).to.be.foo.equal('foo');\r\n *\r\n * @param {Object} ctx object to which the method is added\r\n * @param {String} name of method to add\r\n * @param {Function} method function to be used for `name`, when called\r\n * @param {Function} chainingBehavior function to be called every time the property is accessed\r\n * @name addChainableMethod\r\n * @api public\r\n */\r\n\r\nmodule.exports = function (ctx, name, method, chainingBehavior) {\r\n  if (typeof chainingBehavior !== 'function')\r\n    chainingBehavior = function () { };\r\n\r\n  Object.defineProperty(ctx, name,\r\n    { get: function () {\r\n        chainingBehavior.call(this);\r\n\r\n        var assert = function () {\r\n          var result = method.apply(this, arguments);\r\n          return result === undefined ? this : result;\r\n        };\r\n\r\n        // Use `__proto__` if available\r\n        if (hasProtoSupport) {\r\n          // Inherit all properties from the object by replacing the `Function` prototype\r\n          var prototype = assert.__proto__ = Object.create(this);\r\n          // Restore the `call` and `apply` methods from `Function`\r\n          prototype.call = call;\r\n          prototype.apply = apply;\r\n        }\r\n        // Otherwise, redefine all properties (slow!)\r\n        else {\r\n          var asserterNames = Object.getOwnPropertyNames(ctx);\r\n          asserterNames.forEach(function (asserterName) {\r\n            if (!excludeNames.test(asserterName)) {\r\n              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\r\n              Object.defineProperty(assert, asserterName, pd);\r\n            }\r\n          });\r\n        }\r\n\r\n        transferFlags(this, assert);\r\n        return assert;\r\n      }\r\n    , configurable: true\r\n  });\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/addMethod.js\", function(exports, require, module){\r\n/*!\r\n * Chai - addMethod utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * ### .addMethod (ctx, name, method)\r\n *\r\n * Adds a method to the prototype of an object.\r\n *\r\n *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\r\n *       var obj = utils.flag(this, 'object');\r\n *       new chai.Assertion(obj).to.be.equal(str);\r\n *     });\r\n *\r\n * Can also be accessed directly from `chai.Assertion`.\r\n *\r\n *     chai.Assertion.addMethod('foo', fn);\r\n *\r\n * Then can be used as any other assertion.\r\n *\r\n *     expect(fooStr).to.be.foo('bar');\r\n *\r\n * @param {Object} ctx object to which the method is added\r\n * @param {String} name of method to add\r\n * @param {Function} method function to be used for name\r\n * @name addMethod\r\n * @api public\r\n */\r\n\r\nmodule.exports = function (ctx, name, method) {\r\n  ctx[name] = function () {\r\n    var result = method.apply(this, arguments);\r\n    return result === undefined ? this : result;\r\n  };\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/addProperty.js\", function(exports, require, module){\r\n/*!\r\n * Chai - addProperty utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * ### addProperty (ctx, name, getter)\r\n *\r\n * Adds a property to the prototype of an object.\r\n *\r\n *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\r\n *       var obj = utils.flag(this, 'object');\r\n *       new chai.Assertion(obj).to.be.instanceof(Foo);\r\n *     });\r\n *\r\n * Can also be accessed directly from `chai.Assertion`.\r\n *\r\n *     chai.Assertion.addProperty('foo', fn);\r\n *\r\n * Then can be used as any other assertion.\r\n *\r\n *     expect(myFoo).to.be.foo;\r\n *\r\n * @param {Object} ctx object to which the property is added\r\n * @param {String} name of property to add\r\n * @param {Function} getter function to be used for name\r\n * @name addProperty\r\n * @api public\r\n */\r\n\r\nmodule.exports = function (ctx, name, getter) {\r\n  Object.defineProperty(ctx, name,\r\n    { get: function () {\r\n        var result = getter.call(this);\r\n        return result === undefined ? this : result;\r\n      }\r\n    , configurable: true\r\n  });\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/eql.js\", function(exports, require, module){\r\n// This is (almost) directly from Node.js assert\r\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/assert.js\r\n\r\nmodule.exports = _deepEqual;\r\n\r\nvar getEnumerableProperties = require('./getEnumerableProperties');\r\n\r\n// for the browser\r\nvar Buffer;\r\ntry {\r\n  Buffer = require('buffer').Buffer;\r\n} catch (ex) {\r\n  Buffer = {\r\n    isBuffer: function () { return false; }\r\n  };\r\n}\r\n\r\nfunction _deepEqual(actual, expected, memos) {\r\n\r\n  // 7.1. All identical values are equivalent, as determined by ===.\r\n  if (actual === expected) {\r\n    return true;\r\n\r\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\r\n    if (actual.length != expected.length) return false;\r\n\r\n    for (var i = 0; i < actual.length; i++) {\r\n      if (actual[i] !== expected[i]) return false;\r\n    }\r\n\r\n    return true;\r\n\r\n  // 7.2. If the expected value is a Date object, the actual value is\r\n  // equivalent if it is also a Date object that refers to the same time.\r\n  } else if (actual instanceof Date && expected instanceof Date) {\r\n    return actual.getTime() === expected.getTime();\r\n\r\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\r\n  // equivalence is determined by ==.\r\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\r\n    return actual === expected;\r\n\r\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\r\n  // determined by having the same number of owned properties (as verified\r\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\r\n  // (although not necessarily the same order), equivalent values for every\r\n  // corresponding key, and an identical 'prototype' property. Note: this\r\n  // accounts for both named and indexed properties on Arrays.\r\n  } else {\r\n    return objEquiv(actual, expected, memos);\r\n  }\r\n}\r\n\r\nfunction isUndefinedOrNull(value) {\r\n  return value === null || value === undefined;\r\n}\r\n\r\nfunction isArguments(object) {\r\n  return Object.prototype.toString.call(object) == '[object Arguments]';\r\n}\r\n\r\nfunction objEquiv(a, b, memos) {\r\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\r\n    return false;\r\n\r\n  // an identical 'prototype' property.\r\n  if (a.prototype !== b.prototype) return false;\r\n\r\n  // check if we have already compared a and b\r\n  var i;\r\n  if (memos) {\r\n    for(i = 0; i < memos.length; i++) {\r\n      if ((memos[i][0] === a && memos[i][1] === b) ||\r\n          (memos[i][0] === b && memos[i][1] === a))\r\n        return true;\r\n    }\r\n  } else {\r\n    memos = [];\r\n  }\r\n\r\n  //~~~I've managed to break Object.keys through screwy arguments passing.\r\n  //   Converting to array solves the problem.\r\n  if (isArguments(a)) {\r\n    if (!isArguments(b)) {\r\n      return false;\r\n    }\r\n    a = pSlice.call(a);\r\n    b = pSlice.call(b);\r\n    return _deepEqual(a, b, memos);\r\n  }\r\n  try {\r\n    var ka = getEnumerableProperties(a),\r\n        kb = getEnumerableProperties(b),\r\n        key;\r\n  } catch (e) {//happens when one is a string literal and the other isn't\r\n    return false;\r\n  }\r\n\r\n  // having the same number of owned properties (keys incorporates\r\n  // hasOwnProperty)\r\n  if (ka.length != kb.length)\r\n    return false;\r\n\r\n  //the same set of keys (although not necessarily the same order),\r\n  ka.sort();\r\n  kb.sort();\r\n  //~~~cheap key test\r\n  for (i = ka.length - 1; i >= 0; i--) {\r\n    if (ka[i] != kb[i])\r\n      return false;\r\n  }\r\n\r\n  // remember objects we have compared to guard against circular references\r\n  memos.push([ a, b ]);\r\n\r\n  //equivalent values for every corresponding key, and\r\n  //~~~possibly expensive deep test\r\n  for (i = ka.length - 1; i >= 0; i--) {\r\n    key = ka[i];\r\n    if (!_deepEqual(a[key], b[key], memos)) return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/flag.js\", function(exports, require, module){\r\n/*!\r\n * Chai - flag utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * ### flag(object ,key, [value])\r\n *\r\n * Get or set a flag value on an object. If a\r\n * value is provided it will be set, else it will\r\n * return the currently set value or `undefined` if\r\n * the value is not set.\r\n *\r\n *     utils.flag(this, 'foo', 'bar'); // setter\r\n *     utils.flag(this, 'foo'); // getter, returns `bar`\r\n *\r\n * @param {Object} object (constructed Assertion\r\n * @param {String} key\r\n * @param {Mixed} value (optional)\r\n * @name flag\r\n * @api private\r\n */\r\n\r\nmodule.exports = function (obj, key, value) {\r\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\r\n  if (arguments.length === 3) {\r\n    flags[key] = value;\r\n  } else {\r\n    return flags[key];\r\n  }\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/getActual.js\", function(exports, require, module){\r\n/*!\r\n * Chai - getActual utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * # getActual(object, [actual])\r\n *\r\n * Returns the `actual` value for an Assertion\r\n *\r\n * @param {Object} object (constructed Assertion)\r\n * @param {Arguments} chai.Assertion.prototype.assert arguments\r\n */\r\n\r\nmodule.exports = function (obj, args) {\r\n  var actual = args[4];\r\n  return 'undefined' !== typeof actual ? actual : obj._obj;\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/getEnumerableProperties.js\", function(exports, require, module){\r\n/*!\r\n * Chai - getEnumerableProperties utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * ### .getEnumerableProperties(object)\r\n *\r\n * This allows the retrieval of enumerable property names of an object,\r\n * inherited or not.\r\n *\r\n * @param {Object} object\r\n * @returns {Array}\r\n * @name getEnumerableProperties\r\n * @api public\r\n */\r\n\r\nmodule.exports = function getEnumerableProperties(object) {\r\n  var result = [];\r\n  for (var name in object) {\r\n    result.push(name);\r\n  }\r\n  return result;\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/getMessage.js\", function(exports, require, module){\r\n/*!\r\n * Chai - message composition utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/*!\r\n * Module dependancies\r\n */\r\n\r\nvar flag = require('./flag')\r\n  , getActual = require('./getActual')\r\n  , inspect = require('./inspect')\r\n  , objDisplay = require('./objDisplay');\r\n\r\n/**\r\n * ### .getMessage(object, message, negateMessage)\r\n *\r\n * Construct the error message based on flags\r\n * and template tags. Template tags will return\r\n * a stringified inspection of the object referenced.\r\n *\r\n * Messsage template tags:\r\n * - `#{this}` current asserted object\r\n * - `#{act}` actual value\r\n * - `#{exp}` expected value\r\n *\r\n * @param {Object} object (constructed Assertion)\r\n * @param {Arguments} chai.Assertion.prototype.assert arguments\r\n * @name getMessage\r\n * @api public\r\n */\r\n\r\nmodule.exports = function (obj, args) {\r\n  var negate = flag(obj, 'negate')\r\n    , val = flag(obj, 'object')\r\n    , expected = args[3]\r\n    , actual = getActual(obj, args)\r\n    , msg = negate ? args[2] : args[1]\r\n    , flagMsg = flag(obj, 'message');\r\n\r\n  msg = msg || '';\r\n  msg = msg\r\n    .replace(/#{this}/g, objDisplay(val))\r\n    .replace(/#{act}/g, objDisplay(actual))\r\n    .replace(/#{exp}/g, objDisplay(expected));\r\n\r\n  return flagMsg ? flagMsg + ': ' + msg : msg;\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/getName.js\", function(exports, require, module){\r\n/*!\r\n * Chai - getName utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * # getName(func)\r\n *\r\n * Gets the name of a function, in a cross-browser way.\r\n *\r\n * @param {Function} a function (usually a constructor)\r\n */\r\n\r\nmodule.exports = function (func) {\r\n  if (func.name) return func.name;\r\n\r\n  var match = /^\\s?function ([^(]*)\\(/.exec(func);\r\n  return match && match[1] ? match[1] : \"\";\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/getPathValue.js\", function(exports, require, module){\r\n/*!\r\n * Chai - getPathValue utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * @see https://github.com/logicalparadox/filtr\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * ### .getPathValue(path, object)\r\n *\r\n * This allows the retrieval of values in an\r\n * object given a string path.\r\n *\r\n *     var obj = {\r\n *         prop1: {\r\n *             arr: ['a', 'b', 'c']\r\n *           , str: 'Hello'\r\n *         }\r\n *       , prop2: {\r\n *             arr: [ { nested: 'Universe' } ]\r\n *           , str: 'Hello again!'\r\n *         }\r\n *     }\r\n *\r\n * The following would be the results.\r\n *\r\n *     getPathValue('prop1.str', obj); // Hello\r\n *     getPathValue('prop1.att[2]', obj); // b\r\n *     getPathValue('prop2.arr[0].nested', obj); // Universe\r\n *\r\n * @param {String} path\r\n * @param {Object} object\r\n * @returns {Object} value or `undefined`\r\n * @name getPathValue\r\n * @api public\r\n */\r\n\r\nvar getPathValue = module.exports = function (path, obj) {\r\n  var parsed = parsePath(path);\r\n  return _getPathValue(parsed, obj);\r\n};\r\n\r\n/*!\r\n * ## parsePath(path)\r\n *\r\n * Helper function used to parse string object\r\n * paths. Use in conjunction with `_getPathValue`.\r\n *\r\n *      var parsed = parsePath('myobject.property.subprop');\r\n *\r\n * ### Paths:\r\n *\r\n * * Can be as near infinitely deep and nested\r\n * * Arrays are also valid using the formal `myobject.document[3].property`.\r\n *\r\n * @param {String} path\r\n * @returns {Object} parsed\r\n * @api private\r\n */\r\n\r\nfunction parsePath (path) {\r\n  var str = path.replace(/\\[/g, '.[')\r\n    , parts = str.match(/(\\\\\\.|[^.]+?)+/g);\r\n  return parts.map(function (value) {\r\n    var re = /\\[(\\d+)\\]$/\r\n      , mArr = re.exec(value)\r\n    if (mArr) return { i: parseFloat(mArr[1]) };\r\n    else return { p: value };\r\n  });\r\n};\r\n\r\n/*!\r\n * ## _getPathValue(parsed, obj)\r\n *\r\n * Helper companion function for `.parsePath` that returns\r\n * the value located at the parsed address.\r\n *\r\n *      var value = getPathValue(parsed, obj);\r\n *\r\n * @param {Object} parsed definition from `parsePath`.\r\n * @param {Object} object to search against\r\n * @returns {Object|Undefined} value\r\n * @api private\r\n */\r\n\r\nfunction _getPathValue (parsed, obj) {\r\n  var tmp = obj\r\n    , res;\r\n  for (var i = 0, l = parsed.length; i < l; i++) {\r\n    var part = parsed[i];\r\n    if (tmp) {\r\n      if ('undefined' !== typeof part.p)\r\n        tmp = tmp[part.p];\r\n      else if ('undefined' !== typeof part.i)\r\n        tmp = tmp[part.i];\r\n      if (i == (l - 1)) res = tmp;\r\n    } else {\r\n      res = undefined;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/getProperties.js\", function(exports, require, module){\r\n/*!\r\n * Chai - getProperties utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * ### .getProperties(object)\r\n *\r\n * This allows the retrieval of property names of an object, enumerable or not,\r\n * inherited or not.\r\n *\r\n * @param {Object} object\r\n * @returns {Array}\r\n * @name getProperties\r\n * @api public\r\n */\r\n\r\nmodule.exports = function getProperties(object) {\r\n  var result = Object.getOwnPropertyNames(subject);\r\n\r\n  function addProperty(property) {\r\n    if (result.indexOf(property) === -1) {\r\n      result.push(property);\r\n    }\r\n  }\r\n\r\n  var proto = Object.getPrototypeOf(subject);\r\n  while (proto !== null) {\r\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/index.js\", function(exports, require, module){\r\n/*!\r\n * chai\r\n * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/*!\r\n * Main exports\r\n */\r\n\r\nvar exports = module.exports = {};\r\n\r\n/*!\r\n * test utility\r\n */\r\n\r\nexports.test = require('./test');\r\n\r\n/*!\r\n * type utility\r\n */\r\n\r\nexports.type = require('./type');\r\n\r\n/*!\r\n * message utility\r\n */\r\n\r\nexports.getMessage = require('./getMessage');\r\n\r\n/*!\r\n * actual utility\r\n */\r\n\r\nexports.getActual = require('./getActual');\r\n\r\n/*!\r\n * Inspect util\r\n */\r\n\r\nexports.inspect = require('./inspect');\r\n\r\n/*!\r\n * Object Display util\r\n */\r\n\r\nexports.objDisplay = require('./objDisplay');\r\n\r\n/*!\r\n * Flag utility\r\n */\r\n\r\nexports.flag = require('./flag');\r\n\r\n/*!\r\n * Flag transferring utility\r\n */\r\n\r\nexports.transferFlags = require('./transferFlags');\r\n\r\n/*!\r\n * Deep equal utility\r\n */\r\n\r\nexports.eql = require('./eql');\r\n\r\n/*!\r\n * Deep path value\r\n */\r\n\r\nexports.getPathValue = require('./getPathValue');\r\n\r\n/*!\r\n * Function name\r\n */\r\n\r\nexports.getName = require('./getName');\r\n\r\n/*!\r\n * add Property\r\n */\r\n\r\nexports.addProperty = require('./addProperty');\r\n\r\n/*!\r\n * add Method\r\n */\r\n\r\nexports.addMethod = require('./addMethod');\r\n\r\n/*!\r\n * overwrite Property\r\n */\r\n\r\nexports.overwriteProperty = require('./overwriteProperty');\r\n\r\n/*!\r\n * overwrite Method\r\n */\r\n\r\nexports.overwriteMethod = require('./overwriteMethod');\r\n\r\n/*!\r\n * Add a chainable method\r\n */\r\n\r\nexports.addChainableMethod = require('./addChainableMethod');\r\n\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/inspect.js\", function(exports, require, module){\r\n// This is (almost) directly from Node.js utils\r\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\r\n\r\nvar getName = require('./getName');\r\nvar getProperties = require('./getProperties');\r\nvar getEnumerableProperties = require('./getEnumerableProperties');\r\n\r\nmodule.exports = inspect;\r\n\r\n/**\r\n * Echos the value of a value. Trys to print the value out\r\n * in the best way possible given the different types.\r\n *\r\n * @param {Object} obj The object to print out.\r\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\r\n *    properties of objects.\r\n * @param {Number} depth Depth in which to descend in object. Default is 2.\r\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\r\n *    output. Default is false (no coloring).\r\n */\r\nfunction inspect(obj, showHidden, depth, colors) {\r\n  var ctx = {\r\n    showHidden: showHidden,\r\n    seen: [],\r\n    stylize: function (str) { return str; }\r\n  };\r\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\r\n}\r\n\r\n// https://gist.github.com/1044128/\r\nvar getOuterHTML = function(element) {\r\n  if ('outerHTML' in element) return element.outerHTML;\r\n  var ns = \"http://www.w3.org/1999/xhtml\";\r\n  var container = document.createElementNS(ns, '_');\r\n  var elemProto = (window.HTMLElement || window.Element).prototype;\r\n  var xmlSerializer = new XMLSerializer();\r\n  var html;\r\n  if (document.xmlVersion) {\r\n    return xmlSerializer.serializeToString(element);\r\n  } else {\r\n    container.appendChild(element.cloneNode(false));\r\n    html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');\r\n    container.innerHTML = '';\r\n    return html;\r\n  }\r\n};\r\n\r\n// Returns true if object is a DOM element.\r\nvar isDOMElement = function (object) {\r\n  if (typeof HTMLElement === 'object') {\r\n    return object instanceof HTMLElement;\r\n  } else {\r\n    return object &&\r\n      typeof object === 'object' &&\r\n      object.nodeType === 1 &&\r\n      typeof object.nodeName === 'string';\r\n  }\r\n};\r\n\r\nfunction formatValue(ctx, value, recurseTimes) {\r\n  // Provide a hook for user-specified inspect functions.\r\n  // Check that value is an object with an inspect function on it\r\n  if (value && typeof value.inspect === 'function' &&\r\n      // Filter out the util module, it's inspect function is special\r\n      value.inspect !== exports.inspect &&\r\n      // Also filter out any prototype objects using the circular check.\r\n      !(value.constructor && value.constructor.prototype === value)) {\r\n    return value.inspect(recurseTimes);\r\n  }\r\n\r\n  // Primitive types cannot have properties\r\n  var primitive = formatPrimitive(ctx, value);\r\n  if (primitive) {\r\n    return primitive;\r\n  }\r\n\r\n  // If it's DOM elem, get outer HTML.\r\n  if (isDOMElement(value)) {\r\n    return getOuterHTML(value);\r\n  }\r\n\r\n  // Look up the keys of the object.\r\n  var visibleKeys = getEnumerableProperties(value);\r\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\r\n\r\n  // Some type of object without properties can be shortcutted.\r\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\r\n  // a `stack` plus `description` property; ignore those for consistency.\r\n  if (keys.length === 0 || (isError(value) && (\r\n      (keys.length === 1 && keys[0] === 'stack') ||\r\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\r\n     ))) {\r\n    if (typeof value === 'function') {\r\n      var name = getName(value);\r\n      var nameSuffix = name ? ': ' + name : '';\r\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\r\n    }\r\n    if (isRegExp(value)) {\r\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\r\n    }\r\n    if (isDate(value)) {\r\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\r\n    }\r\n    if (isError(value)) {\r\n      return formatError(value);\r\n    }\r\n  }\r\n\r\n  var base = '', array = false, braces = ['{', '}'];\r\n\r\n  // Make Array say that they are Array\r\n  if (isArray(value)) {\r\n    array = true;\r\n    braces = ['[', ']'];\r\n  }\r\n\r\n  // Make functions say that they are functions\r\n  if (typeof value === 'function') {\r\n    var name = getName(value);\r\n    var nameSuffix = name ? ': ' + name : '';\r\n    base = ' [Function' + nameSuffix + ']';\r\n  }\r\n\r\n  // Make RegExps say that they are RegExps\r\n  if (isRegExp(value)) {\r\n    base = ' ' + RegExp.prototype.toString.call(value);\r\n  }\r\n\r\n  // Make dates with properties first say the date\r\n  if (isDate(value)) {\r\n    base = ' ' + Date.prototype.toUTCString.call(value);\r\n  }\r\n\r\n  // Make error with message first say the error\r\n  if (isError(value)) {\r\n    return formatError(value);\r\n  }\r\n\r\n  if (keys.length === 0 && (!array || value.length == 0)) {\r\n    return braces[0] + base + braces[1];\r\n  }\r\n\r\n  if (recurseTimes < 0) {\r\n    if (isRegExp(value)) {\r\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\r\n    } else {\r\n      return ctx.stylize('[Object]', 'special');\r\n    }\r\n  }\r\n\r\n  ctx.seen.push(value);\r\n\r\n  var output;\r\n  if (array) {\r\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\r\n  } else {\r\n    output = keys.map(function(key) {\r\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\r\n    });\r\n  }\r\n\r\n  ctx.seen.pop();\r\n\r\n  return reduceToSingleString(output, base, braces);\r\n}\r\n\r\n\r\nfunction formatPrimitive(ctx, value) {\r\n  switch (typeof value) {\r\n    case 'undefined':\r\n      return ctx.stylize('undefined', 'undefined');\r\n\r\n    case 'string':\r\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\r\n                                               .replace(/'/g, \"\\\\'\")\r\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\r\n      return ctx.stylize(simple, 'string');\r\n\r\n    case 'number':\r\n      return ctx.stylize('' + value, 'number');\r\n\r\n    case 'boolean':\r\n      return ctx.stylize('' + value, 'boolean');\r\n  }\r\n  // For some reason typeof null is \"object\", so special case here.\r\n  if (value === null) {\r\n    return ctx.stylize('null', 'null');\r\n  }\r\n}\r\n\r\n\r\nfunction formatError(value) {\r\n  return '[' + Error.prototype.toString.call(value) + ']';\r\n}\r\n\r\n\r\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\r\n  var output = [];\r\n  for (var i = 0, l = value.length; i < l; ++i) {\r\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\r\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n          String(i), true));\r\n    } else {\r\n      output.push('');\r\n    }\r\n  }\r\n  keys.forEach(function(key) {\r\n    if (!key.match(/^\\d+$/)) {\r\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n          key, true));\r\n    }\r\n  });\r\n  return output;\r\n}\r\n\r\n\r\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\r\n  var name, str;\r\n  if (value.__lookupGetter__) {\r\n    if (value.__lookupGetter__(key)) {\r\n      if (value.__lookupSetter__(key)) {\r\n        str = ctx.stylize('[Getter/Setter]', 'special');\r\n      } else {\r\n        str = ctx.stylize('[Getter]', 'special');\r\n      }\r\n    } else {\r\n      if (value.__lookupSetter__(key)) {\r\n        str = ctx.stylize('[Setter]', 'special');\r\n      }\r\n    }\r\n  }\r\n  if (visibleKeys.indexOf(key) < 0) {\r\n    name = '[' + key + ']';\r\n  }\r\n  if (!str) {\r\n    if (ctx.seen.indexOf(value[key]) < 0) {\r\n      if (recurseTimes === null) {\r\n        str = formatValue(ctx, value[key], null);\r\n      } else {\r\n        str = formatValue(ctx, value[key], recurseTimes - 1);\r\n      }\r\n      if (str.indexOf('\\n') > -1) {\r\n        if (array) {\r\n          str = str.split('\\n').map(function(line) {\r\n            return '  ' + line;\r\n          }).join('\\n').substr(2);\r\n        } else {\r\n          str = '\\n' + str.split('\\n').map(function(line) {\r\n            return '   ' + line;\r\n          }).join('\\n');\r\n        }\r\n      }\r\n    } else {\r\n      str = ctx.stylize('[Circular]', 'special');\r\n    }\r\n  }\r\n  if (typeof name === 'undefined') {\r\n    if (array && key.match(/^\\d+$/)) {\r\n      return str;\r\n    }\r\n    name = JSON.stringify('' + key);\r\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\r\n      name = name.substr(1, name.length - 2);\r\n      name = ctx.stylize(name, 'name');\r\n    } else {\r\n      name = name.replace(/'/g, \"\\\\'\")\r\n                 .replace(/\\\\\"/g, '\"')\r\n                 .replace(/(^\"|\"$)/g, \"'\");\r\n      name = ctx.stylize(name, 'string');\r\n    }\r\n  }\r\n\r\n  return name + ': ' + str;\r\n}\r\n\r\n\r\nfunction reduceToSingleString(output, base, braces) {\r\n  var numLinesEst = 0;\r\n  var length = output.reduce(function(prev, cur) {\r\n    numLinesEst++;\r\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\r\n    return prev + cur.length + 1;\r\n  }, 0);\r\n\r\n  if (length > 60) {\r\n    return braces[0] +\r\n           (base === '' ? '' : base + '\\n ') +\r\n           ' ' +\r\n           output.join(',\\n  ') +\r\n           ' ' +\r\n           braces[1];\r\n  }\r\n\r\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\r\n}\r\n\r\nfunction isArray(ar) {\r\n  return Array.isArray(ar) ||\r\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\r\n}\r\n\r\nfunction isRegExp(re) {\r\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\r\n}\r\n\r\nfunction isDate(d) {\r\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\r\n}\r\n\r\nfunction isError(e) {\r\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\r\n}\r\n\r\nfunction objectToString(o) {\r\n  return Object.prototype.toString.call(o);\r\n}\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/objDisplay.js\", function(exports, require, module){\r\n/*!\r\n * Chai - flag utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/*!\r\n * Module dependancies\r\n */\r\n\r\nvar inspect = require('./inspect');\r\n\r\n/**\r\n * ### .objDisplay (object)\r\n *\r\n * Determines if an object or an array matches\r\n * criteria to be inspected in-line for error\r\n * messages or should be truncated.\r\n *\r\n * @param {Mixed} javascript object to inspect\r\n * @name objDisplay\r\n * @api public\r\n */\r\n\r\nmodule.exports = function (obj) {\r\n  var str = inspect(obj)\r\n    , type = Object.prototype.toString.call(obj);\r\n\r\n  if (str.length >= 40) {\r\n    if (type === '[object Function]') {\r\n      return !obj.name || obj.name === ''\r\n        ? '[Function]'\r\n        : '[Function: ' + obj.name + ']';\r\n    } else if (type === '[object Array]') {\r\n      return '[ Array(' + obj.length + ') ]';\r\n    } else if (type === '[object Object]') {\r\n      var keys = Object.keys(obj)\r\n        , kstr = keys.length > 2\r\n          ? keys.splice(0, 2).join(', ') + ', ...'\r\n          : keys.join(', ');\r\n      return '{ Object (' + kstr + ') }';\r\n    } else {\r\n      return str;\r\n    }\r\n  } else {\r\n    return str;\r\n  }\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/overwriteMethod.js\", function(exports, require, module){\r\n/*!\r\n * Chai - overwriteMethod utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * ### overwriteMethod (ctx, name, fn)\r\n *\r\n * Overwites an already existing method and provides\r\n * access to previous function. Must return function\r\n * to be used for name.\r\n *\r\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\r\n *       return function (str) {\r\n *         var obj = utils.flag(this, 'object');\r\n *         if (obj instanceof Foo) {\r\n *           new chai.Assertion(obj.value).to.equal(str);\r\n *         } else {\r\n *           _super.apply(this, arguments);\r\n *         }\r\n *       }\r\n *     });\r\n *\r\n * Can also be accessed directly from `chai.Assertion`.\r\n *\r\n *     chai.Assertion.overwriteMethod('foo', fn);\r\n *\r\n * Then can be used as any other assertion.\r\n *\r\n *     expect(myFoo).to.equal('bar');\r\n *\r\n * @param {Object} ctx object whose method is to be overwritten\r\n * @param {String} name of method to overwrite\r\n * @param {Function} method function that returns a function to be used for name\r\n * @name overwriteMethod\r\n * @api public\r\n */\r\n\r\nmodule.exports = function (ctx, name, method) {\r\n  var _method = ctx[name]\r\n    , _super = function () { return this; };\r\n\r\n  if (_method && 'function' === typeof _method)\r\n    _super = _method;\r\n\r\n  ctx[name] = function () {\r\n    var result = method(_super).apply(this, arguments);\r\n    return result === undefined ? this : result;\r\n  }\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/overwriteProperty.js\", function(exports, require, module){\r\n/*!\r\n * Chai - overwriteProperty utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * ### overwriteProperty (ctx, name, fn)\r\n *\r\n * Overwites an already existing property getter and provides\r\n * access to previous value. Must return function to use as getter.\r\n *\r\n *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\r\n *       return function () {\r\n *         var obj = utils.flag(this, 'object');\r\n *         if (obj instanceof Foo) {\r\n *           new chai.Assertion(obj.name).to.equal('bar');\r\n *         } else {\r\n *           _super.call(this);\r\n *         }\r\n *       }\r\n *     });\r\n *\r\n *\r\n * Can also be accessed directly from `chai.Assertion`.\r\n *\r\n *     chai.Assertion.overwriteProperty('foo', fn);\r\n *\r\n * Then can be used as any other assertion.\r\n *\r\n *     expect(myFoo).to.be.ok;\r\n *\r\n * @param {Object} ctx object whose property is to be overwritten\r\n * @param {String} name of property to overwrite\r\n * @param {Function} getter function that returns a getter function to be used for name\r\n * @name overwriteProperty\r\n * @api public\r\n */\r\n\r\nmodule.exports = function (ctx, name, getter) {\r\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\r\n    , _super = function () {};\r\n\r\n  if (_get && 'function' === typeof _get.get)\r\n    _super = _get.get\r\n\r\n  Object.defineProperty(ctx, name,\r\n    { get: function () {\r\n        var result = getter(_super).call(this);\r\n        return result === undefined ? this : result;\r\n      }\r\n    , configurable: true\r\n  });\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/test.js\", function(exports, require, module){\r\n/*!\r\n * Chai - test utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/*!\r\n * Module dependancies\r\n */\r\n\r\nvar flag = require('./flag');\r\n\r\n/**\r\n * # test(object, expression)\r\n *\r\n * Test and object for expression.\r\n *\r\n * @param {Object} object (constructed Assertion)\r\n * @param {Arguments} chai.Assertion.prototype.assert arguments\r\n */\r\n\r\nmodule.exports = function (obj, args) {\r\n  var negate = flag(obj, 'negate')\r\n    , expr = args[0];\r\n  return negate ? !expr : expr;\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/transferFlags.js\", function(exports, require, module){\r\n/*!\r\n * Chai - transferFlags utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * ### transferFlags(assertion, object, includeAll = true)\r\n *\r\n * Transfer all the flags for `assertion` to `object`. If\r\n * `includeAll` is set to `false`, then the base Chai\r\n * assertion flags (namely `object`, `ssfi`, and `message`)\r\n * will not be transferred.\r\n *\r\n *\r\n *     var newAssertion = new Assertion();\r\n *     utils.transferFlags(assertion, newAssertion);\r\n *\r\n *     var anotherAsseriton = new Assertion(myObj);\r\n *     utils.transferFlags(assertion, anotherAssertion, false);\r\n *\r\n * @param {Assertion} assertion the assertion to transfer the flags from\r\n * @param {Object} object the object to transfer the flags too; usually a new assertion\r\n * @param {Boolean} includeAll\r\n * @name getAllFlags\r\n * @api private\r\n */\r\n\r\nmodule.exports = function (assertion, object, includeAll) {\r\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\r\n\r\n  if (!object.__flags) {\r\n    object.__flags = Object.create(null);\r\n  }\r\n\r\n  includeAll = arguments.length === 3 ? includeAll : true;\r\n\r\n  for (var flag in flags) {\r\n    if (includeAll ||\r\n        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {\r\n      object.__flags[flag] = flags[flag];\r\n    }\r\n  }\r\n};\r\n\r\n});\r\nrequire.register(\"chai/lib/chai/utils/type.js\", function(exports, require, module){\r\n/*!\r\n * Chai - type utility\r\n * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n * MIT Licensed\r\n */\r\n\r\n/*!\r\n * Detectable javascript natives\r\n */\r\n\r\nvar natives = {\r\n    '[object Arguments]': 'arguments'\r\n  , '[object Array]': 'array'\r\n  , '[object Date]': 'date'\r\n  , '[object Function]': 'function'\r\n  , '[object Number]': 'number'\r\n  , '[object RegExp]': 'regexp'\r\n  , '[object String]': 'string'\r\n};\r\n\r\n/**\r\n * ### type(object)\r\n *\r\n * Better implementation of `typeof` detection that can\r\n * be used cross-browser. Handles the inconsistencies of\r\n * Array, `null`, and `undefined` detection.\r\n *\r\n *     utils.type({}) // 'object'\r\n *     utils.type(null) // `null'\r\n *     utils.type(undefined) // `undefined`\r\n *     utils.type([]) // `array`\r\n *\r\n * @param {Mixed} object to detect type of\r\n * @name type\r\n * @api private\r\n */\r\n\r\nmodule.exports = function (obj) {\r\n  var str = Object.prototype.toString.call(obj);\r\n  if (natives[str]) return natives[str];\r\n  if (obj === null) return 'null';\r\n  if (obj === undefined) return 'undefined';\r\n  if (obj === Object(obj)) return 'object';\r\n  return typeof obj;\r\n};\r\n\r\n});\r\nrequire.alias(\"chai/index.js\", \"chai/index.js\");\r\n\r\nif (typeof exports == \"object\") {\r\n  module.exports = require(\"chai\");\r\n} else if (typeof define == \"function\" && define.amd) {\r\n  define(function(){ return require(\"chai\"); });\r\n} else {\r\n  this[\"chai\"] = require(\"chai\");\r\n}})();"]],"start1":0,"start2":0,"length1":0,"length2":111772}]],"length":111772,"saved":false}
