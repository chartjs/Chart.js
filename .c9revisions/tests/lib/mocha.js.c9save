{"ts":1367326773157,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1367326860321,"patch":[[{"diffs":[[1,";(function(){\r\n\r\n// CommonJS require()\r\n\r\nfunction require(p){\r\n    var path = require.resolve(p)\r\n      , mod = require.modules[path];\r\n    if (!mod) throw new Error('failed to require \"' + p + '\"');\r\n    if (!mod.exports) {\r\n      mod.exports = {};\r\n      mod.call(mod.exports, mod, mod.exports, require.relative(path));\r\n    }\r\n    return mod.exports;\r\n  }\r\n\r\nrequire.modules = {};\r\n\r\nrequire.resolve = function (path){\r\n    var orig = path\r\n      , reg = path + '.js'\r\n      , index = path + '/index.js';\r\n    return require.modules[reg] && reg\r\n      || require.modules[index] && index\r\n      || orig;\r\n  };\r\n\r\nrequire.register = function (path, fn){\r\n    require.modules[path] = fn;\r\n  };\r\n\r\nrequire.relative = function (parent) {\r\n    return function(p){\r\n      if ('.' != p.charAt(0)) return require(p);\r\n\r\n      var path = parent.split('/')\r\n        , segs = p.split('/');\r\n      path.pop();\r\n\r\n      for (var i = 0; i < segs.length; i++) {\r\n        var seg = segs[i];\r\n        if ('..' == seg) path.pop();\r\n        else if ('.' != seg) path.push(seg);\r\n      }\r\n\r\n      return require(path.join('/'));\r\n    };\r\n  };\r\n\r\n\r\nrequire.register(\"browser/debug.js\", function(module, exports, require){\r\n\r\nmodule.exports = function(type){\r\n  return function(){\r\n  }\r\n};\r\n\r\n}); // module: browser/debug.js\r\n\r\nrequire.register(\"browser/diff.js\", function(module, exports, require){\r\n/* See license.txt for terms of usage */\r\n\r\n/*\r\n * Text diff implementation.\r\n * \r\n * This library supports the following APIS:\r\n * JsDiff.diffChars: Character by character diff\r\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\r\n * JsDiff.diffLines: Line based diff\r\n * \r\n * JsDiff.diffCss: Diff targeted at CSS content\r\n * \r\n * These methods are based on the implementation proposed in\r\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\r\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\r\n */\r\nvar JsDiff = (function() {\r\n  function clonePath(path) {\r\n    return { newPos: path.newPos, components: path.components.slice(0) };\r\n  }\r\n  function removeEmpty(array) {\r\n    var ret = [];\r\n    for (var i = 0; i < array.length; i++) {\r\n      if (array[i]) {\r\n        ret.push(array[i]);\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n  function escapeHTML(s) {\r\n    var n = s;\r\n    n = n.replace(/&/g, \"&amp;\");\r\n    n = n.replace(/</g, \"&lt;\");\r\n    n = n.replace(/>/g, \"&gt;\");\r\n    n = n.replace(/\"/g, \"&quot;\");\r\n\r\n    return n;\r\n  }\r\n\r\n\r\n  var fbDiff = function(ignoreWhitespace) {\r\n    this.ignoreWhitespace = ignoreWhitespace;\r\n  };\r\n  fbDiff.prototype = {\r\n      diff: function(oldString, newString) {\r\n        // Handle the identity case (this is due to unrolling editLength == 0\r\n        if (newString == oldString) {\r\n          return [{ value: newString }];\r\n        }\r\n        if (!newString) {\r\n          return [{ value: oldString, removed: true }];\r\n        }\r\n        if (!oldString) {\r\n          return [{ value: newString, added: true }];\r\n        }\r\n\r\n        newString = this.tokenize(newString);\r\n        oldString = this.tokenize(oldString);\r\n\r\n        var newLen = newString.length, oldLen = oldString.length;\r\n        var maxEditLength = newLen + oldLen;\r\n        var bestPath = [{ newPos: -1, components: [] }];\r\n\r\n        // Seed editLength = 0\r\n        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\r\n        if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {\r\n          return bestPath[0].components;\r\n        }\r\n\r\n        for (var editLength = 1; editLength <= maxEditLength; editLength++) {\r\n          for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {\r\n            var basePath;\r\n            var addPath = bestPath[diagonalPath-1],\r\n                removePath = bestPath[diagonalPath+1];\r\n            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\r\n            if (addPath) {\r\n              // No one else is going to attempt to use this value, clear it\r\n              bestPath[diagonalPath-1] = undefined;\r\n            }\r\n\r\n            var canAdd = addPath && addPath.newPos+1 < newLen;\r\n            var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\r\n            if (!canAdd && !canRemove) {\r\n              bestPath[diagonalPath] = undefined;\r\n              continue;\r\n            }\r\n\r\n            // Select the diagonal that we want to branch from. We select the prior\r\n            // path whose position in the new string is the farthest from the origin\r\n            // and does not pass the bounds of the diff graph\r\n            if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\r\n              basePath = clonePath(removePath);\r\n              this.pushComponent(basePath.components, oldString[oldPos], undefined, true);\r\n            } else {\r\n              basePath = clonePath(addPath);\r\n              basePath.newPos++;\r\n              this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);\r\n            }\r\n\r\n            var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);\r\n\r\n            if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {\r\n              return basePath.components;\r\n            } else {\r\n              bestPath[diagonalPath] = basePath;\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      pushComponent: function(components, value, added, removed) {\r\n        var last = components[components.length-1];\r\n        if (last && last.added === added && last.removed === removed) {\r\n          // We need to clone here as the component clone operation is just\r\n          // as shallow array clone\r\n          components[components.length-1] =\r\n            {value: this.join(last.value, value), added: added, removed: removed };\r\n        } else {\r\n          components.push({value: value, added: added, removed: removed });\r\n        }\r\n      },\r\n      extractCommon: function(basePath, newString, oldString, diagonalPath) {\r\n        var newLen = newString.length,\r\n            oldLen = oldString.length,\r\n            newPos = basePath.newPos,\r\n            oldPos = newPos - diagonalPath;\r\n        while (newPos+1 < newLen && oldPos+1 < oldLen && this.equals(newString[newPos+1], oldString[oldPos+1])) {\r\n          newPos++;\r\n          oldPos++;\r\n          \r\n          this.pushComponent(basePath.components, newString[newPos], undefined, undefined);\r\n        }\r\n        basePath.newPos = newPos;\r\n        return oldPos;\r\n      },\r\n\r\n      equals: function(left, right) {\r\n        var reWhitespace = /\\S/;\r\n        if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {\r\n          return true;\r\n        } else {\r\n          return left == right;\r\n        }\r\n      },\r\n      join: function(left, right) {\r\n        return left + right;\r\n      },\r\n      tokenize: function(value) {\r\n        return value;\r\n      }\r\n  };\r\n  \r\n  var CharDiff = new fbDiff();\r\n  \r\n  var WordDiff = new fbDiff(true);\r\n  WordDiff.tokenize = function(value) {\r\n    return removeEmpty(value.split(/(\\s+|\\b)/));\r\n  };\r\n  \r\n  var CssDiff = new fbDiff(true);\r\n  CssDiff.tokenize = function(value) {\r\n    return removeEmpty(value.split(/([{}:;,]|\\s+)/));\r\n  };\r\n  \r\n  var LineDiff = new fbDiff();\r\n  LineDiff.tokenize = function(value) {\r\n    return value.split(/^/m);\r\n  };\r\n  \r\n  return {\r\n    diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },\r\n    diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },\r\n    diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },\r\n\r\n    diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },\r\n\r\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\r\n      var ret = [];\r\n\r\n      ret.push(\"Index: \" + fileName);\r\n      ret.push(\"===================================================================\");\r\n      ret.push(\"--- \" + fileName + (typeof oldHeader === \"undefined\" ? \"\" : \"\\t\" + oldHeader));\r\n      ret.push(\"+++ \" + fileName + (typeof newHeader === \"undefined\" ? \"\" : \"\\t\" + newHeader));\r\n\r\n      var diff = LineDiff.diff(oldStr, newStr);\r\n      if (!diff[diff.length-1].value) {\r\n        diff.pop();   // Remove trailing newline add\r\n      }\r\n      diff.push({value: \"\", lines: []});   // Append an empty value to make cleanup easier\r\n\r\n      function contextLines(lines) {\r\n        return lines.map(function(entry) { return ' ' + entry; });\r\n      }\r\n      function eofNL(curRange, i, current) {\r\n        var last = diff[diff.length-2],\r\n            isLast = i === diff.length-2,\r\n            isLastOfType = i === diff.length-3 && (current.added === !last.added || current.removed === !last.removed);\r\n\r\n        // Figure out if this is the last line for the given file and missing NL\r\n        if (!/\\n$/.test(current.value) && (isLast || isLastOfType)) {\r\n          curRange.push('\\\\ No newline at end of file');\r\n        }\r\n      }\r\n\r\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\r\n          oldLine = 1, newLine = 1;\r\n      for (var i = 0; i < diff.length; i++) {\r\n        var current = diff[i],\r\n            lines = current.lines || current.value.replace(/\\n$/, \"\").split(\"\\n\");\r\n        current.lines = lines;\r\n\r\n        if (current.added || current.removed) {\r\n          if (!oldRangeStart) {\r\n            var prev = diff[i-1];\r\n            oldRangeStart = oldLine;\r\n            newRangeStart = newLine;\r\n            \r\n            if (prev) {\r\n              curRange = contextLines(prev.lines.slice(-4));\r\n              oldRangeStart -= curRange.length;\r\n              newRangeStart -= curRange.length;\r\n            }\r\n          }\r\n          curRange.push.apply(curRange, lines.map(function(entry) { return (current.added?\"+\":\"-\") + entry; }));\r\n          eofNL(curRange, i, current);\r\n\r\n          if (current.added) {\r\n            newLine += lines.length;\r\n          } else {\r\n            oldLine += lines.length;\r\n          }\r\n        } else {\r\n          if (oldRangeStart) {\r\n            // Close out any changes that have been output (or join overlapping)\r\n            if (lines.length <= 8 && i < diff.length-2) {\r\n              // Overlapping\r\n              curRange.push.apply(curRange, contextLines(lines));\r\n            } else {\r\n              // end the range and output\r\n              var contextSize = Math.min(lines.length, 4);\r\n              ret.push(\r\n                  \"@@ -\" + oldRangeStart + \",\" + (oldLine-oldRangeStart+contextSize)\r\n                  + \" +\" + newRangeStart + \",\" + (newLine-newRangeStart+contextSize)\r\n                  + \" @@\");\r\n              ret.push.apply(ret, curRange);\r\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\r\n              if (lines.length <= 4) {\r\n                eofNL(ret, i, current);\r\n              }\r\n\r\n              oldRangeStart = 0;  newRangeStart = 0; curRange = [];\r\n            }\r\n          }\r\n          oldLine += lines.length;\r\n          newLine += lines.length;\r\n        }\r\n      }\r\n\r\n      return ret.join('\\n') + '\\n';\r\n    },\r\n\r\n    convertChangesToXML: function(changes){\r\n      var ret = [];\r\n      for ( var i = 0; i < changes.length; i++) {\r\n        var change = changes[i];\r\n        if (change.added) {\r\n          ret.push(\"<ins>\");\r\n        } else if (change.removed) {\r\n          ret.push(\"<del>\");\r\n        }\r\n\r\n        ret.push(escapeHTML(change.value));\r\n\r\n        if (change.added) {\r\n          ret.push(\"</ins>\");\r\n        } else if (change.removed) {\r\n          ret.push(\"</del>\");\r\n        }\r\n      }\r\n      return ret.join(\"\");\r\n    }\r\n  };\r\n})();\r\n\r\nif (typeof module !== \"undefined\") {\r\n    module.exports = JsDiff;\r\n}\r\n\r\n}); // module: browser/diff.js\r\n\r\nrequire.register(\"browser/events.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nexports.EventEmitter = EventEmitter;\r\n\r\n/**\r\n * Check if `obj` is an array.\r\n */\r\n\r\nfunction isArray(obj) {\r\n  return '[object Array]' == {}.toString.call(obj);\r\n}\r\n\r\n/**\r\n * Event emitter constructor.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction EventEmitter(){};\r\n\r\n/**\r\n * Adds a listener.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.on = function (name, fn) {\r\n  if (!this.$events) {\r\n    this.$events = {};\r\n  }\r\n\r\n  if (!this.$events[name]) {\r\n    this.$events[name] = fn;\r\n  } else if (isArray(this.$events[name])) {\r\n    this.$events[name].push(fn);\r\n  } else {\r\n    this.$events[name] = [this.$events[name], fn];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n/**\r\n * Adds a volatile listener.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.once = function (name, fn) {\r\n  var self = this;\r\n\r\n  function on () {\r\n    self.removeListener(name, on);\r\n    fn.apply(this, arguments);\r\n  };\r\n\r\n  on.listener = fn;\r\n  this.on(name, on);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Removes a listener.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.removeListener = function (name, fn) {\r\n  if (this.$events && this.$events[name]) {\r\n    var list = this.$events[name];\r\n\r\n    if (isArray(list)) {\r\n      var pos = -1;\r\n\r\n      for (var i = 0, l = list.length; i < l; i++) {\r\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\r\n          pos = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (pos < 0) {\r\n        return this;\r\n      }\r\n\r\n      list.splice(pos, 1);\r\n\r\n      if (!list.length) {\r\n        delete this.$events[name];\r\n      }\r\n    } else if (list === fn || (list.listener && list.listener === fn)) {\r\n      delete this.$events[name];\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Removes all listeners for an event.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.removeAllListeners = function (name) {\r\n  if (name === undefined) {\r\n    this.$events = {};\r\n    return this;\r\n  }\r\n\r\n  if (this.$events && this.$events[name]) {\r\n    this.$events[name] = null;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Gets all listeners for a certain event.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.listeners = function (name) {\r\n  if (!this.$events) {\r\n    this.$events = {};\r\n  }\r\n\r\n  if (!this.$events[name]) {\r\n    this.$events[name] = [];\r\n  }\r\n\r\n  if (!isArray(this.$events[name])) {\r\n    this.$events[name] = [this.$events[name]];\r\n  }\r\n\r\n  return this.$events[name];\r\n};\r\n\r\n/**\r\n * Emits an event.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.emit = function (name) {\r\n  if (!this.$events) {\r\n    return false;\r\n  }\r\n\r\n  var handler = this.$events[name];\r\n\r\n  if (!handler) {\r\n    return false;\r\n  }\r\n\r\n  var args = [].slice.call(arguments, 1);\r\n\r\n  if ('function' == typeof handler) {\r\n    handler.apply(this, args);\r\n  } else if (isArray(handler)) {\r\n    var listeners = handler.slice();\r\n\r\n    for (var i = 0, l = listeners.length; i < l; i++) {\r\n      listeners[i].apply(this, args);\r\n    }\r\n  } else {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n}); // module: browser/events.js\r\n\r\nrequire.register(\"browser/fs.js\", function(module, exports, require){\r\n\r\n}); // module: browser/fs.js\r\n\r\nrequire.register(\"browser/path.js\", function(module, exports, require){\r\n\r\n}); // module: browser/path.js\r\n\r\nrequire.register(\"browser/progress.js\", function(module, exports, require){\r\n\r\n/**\r\n * Expose `Progress`.\r\n */\r\n\r\nmodule.exports = Progress;\r\n\r\n/**\r\n * Initialize a new `Progress` indicator.\r\n */\r\n\r\nfunction Progress() {\r\n  this.percent = 0;\r\n  this.size(0);\r\n  this.fontSize(11);\r\n  this.font('helvetica, arial, sans-serif');\r\n}\r\n\r\n/**\r\n * Set progress size to `n`.\r\n *\r\n * @param {Number} n\r\n * @return {Progress} for chaining\r\n * @api public\r\n */\r\n\r\nProgress.prototype.size = function(n){\r\n  this._size = n;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set text to `str`.\r\n *\r\n * @param {String} str\r\n * @return {Progress} for chaining\r\n * @api public\r\n */\r\n\r\nProgress.prototype.text = function(str){\r\n  this._text = str;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set font size to `n`.\r\n *\r\n * @param {Number} n\r\n * @return {Progress} for chaining\r\n * @api public\r\n */\r\n\r\nProgress.prototype.fontSize = function(n){\r\n  this._fontSize = n;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set font `family`.\r\n *\r\n * @param {String} family\r\n * @return {Progress} for chaining\r\n */\r\n\r\nProgress.prototype.font = function(family){\r\n  this._font = family;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Update percentage to `n`.\r\n *\r\n * @param {Number} n\r\n * @return {Progress} for chaining\r\n */\r\n\r\nProgress.prototype.update = function(n){\r\n  this.percent = n;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Draw on `ctx`.\r\n *\r\n * @param {CanvasRenderingContext2d} ctx\r\n * @return {Progress} for chaining\r\n */\r\n\r\nProgress.prototype.draw = function(ctx){\r\n  var percent = Math.min(this.percent, 100)\r\n    , size = this._size\r\n    , half = size / 2\r\n    , x = half\r\n    , y = half\r\n    , rad = half - 1\r\n    , fontSize = this._fontSize;\r\n\r\n  ctx.font = fontSize + 'px ' + this._font;\r\n\r\n  var angle = Math.PI * 2 * (percent / 100);\r\n  ctx.clearRect(0, 0, size, size);\r\n\r\n  // outer circle\r\n  ctx.strokeStyle = '#9f9f9f';\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, rad, 0, angle, false);\r\n  ctx.stroke();\r\n\r\n  // inner circle\r\n  ctx.strokeStyle = '#eee';\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, rad - 1, 0, angle, true);\r\n  ctx.stroke();\r\n\r\n  // text\r\n  var text = this._text || (percent | 0) + '%'\r\n    , w = ctx.measureText(text).width;\r\n\r\n  ctx.fillText(\r\n      text\r\n    , x - w / 2 + 1\r\n    , y + fontSize / 2 - 1);\r\n\r\n  return this;\r\n};\r\n\r\n}); // module: browser/progress.js\r\n\r\nrequire.register(\"browser/tty.js\", function(module, exports, require){\r\n\r\nexports.isatty = function(){\r\n  return true;\r\n};\r\n\r\nexports.getWindowSize = function(){\r\n  return [window.innerHeight, window.innerWidth];\r\n};\r\n}); // module: browser/tty.js\r\n\r\nrequire.register(\"context.js\", function(module, exports, require){\r\n\r\n/**\r\n * Expose `Context`.\r\n */\r\n\r\nmodule.exports = Context;\r\n\r\n/**\r\n * Initialize a new `Context`.\r\n *\r\n * @api private\r\n */\r\n\r\nfunction Context(){}\r\n\r\n/**\r\n * Set or get the context `Runnable` to `runnable`.\r\n *\r\n * @param {Runnable} runnable\r\n * @return {Context}\r\n * @api private\r\n */\r\n\r\nContext.prototype.runnable = function(runnable){\r\n  if (0 == arguments.length) return this._runnable;\r\n  this.test = this._runnable = runnable;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set test timeout `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {Context} self\r\n * @api private\r\n */\r\n\r\nContext.prototype.timeout = function(ms){\r\n  this.runnable().timeout(ms);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set test slowness threshold `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {Context} self\r\n * @api private\r\n */\r\n\r\nContext.prototype.slow = function(ms){\r\n  this.runnable().slow(ms);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Inspect the context void of `._runnable`.\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nContext.prototype.inspect = function(){\r\n  return JSON.stringify(this, function(key, val){\r\n    if ('_runnable' == key) return;\r\n    if ('test' == key) return;\r\n    return val;\r\n  }, 2);\r\n};\r\n\r\n}); // module: context.js\r\n\r\nrequire.register(\"hook.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Runnable = require('./runnable');\r\n\r\n/**\r\n * Expose `Hook`.\r\n */\r\n\r\nmodule.exports = Hook;\r\n\r\n/**\r\n * Initialize a new `Hook` with the given `title` and callback `fn`.\r\n *\r\n * @param {String} title\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nfunction Hook(title, fn) {\r\n  Runnable.call(this, title, fn);\r\n  this.type = 'hook';\r\n}\r\n\r\n/**\r\n * Inherit from `Runnable.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Runnable.prototype;\r\nHook.prototype = new F;\r\nHook.prototype.constructor = Hook;\r\n\r\n\r\n/**\r\n * Get or set the test `err`.\r\n *\r\n * @param {Error} err\r\n * @return {Error}\r\n * @api public\r\n */\r\n\r\nHook.prototype.error = function(err){\r\n  if (0 == arguments.length) {\r\n    var err = this._error;\r\n    this._error = null;\r\n    return err;\r\n  }\r\n\r\n  this._error = err;\r\n};\r\n\r\n}); // module: hook.js\r\n\r\nrequire.register(\"interfaces/bdd.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * BDD-style interface:\r\n *\r\n *      describe('Array', function(){\r\n *        describe('#indexOf()', function(){\r\n *          it('should return -1 when not present', function(){\r\n *\r\n *          });\r\n *\r\n *          it('should return the index when present', function(){\r\n *\r\n *          });\r\n *        });\r\n *      });\r\n *\r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('pre-require', function(context, file, mocha){\r\n\r\n    /**\r\n     * Execute before running tests.\r\n     */\r\n\r\n    context.before = function(fn){\r\n      suites[0].beforeAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after running tests.\r\n     */\r\n\r\n    context.after = function(fn){\r\n      suites[0].afterAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute before each test case.\r\n     */\r\n\r\n    context.beforeEach = function(fn){\r\n      suites[0].beforeEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after each test case.\r\n     */\r\n\r\n    context.afterEach = function(fn){\r\n      suites[0].afterEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Describe a \"suite\" with the given `title`\r\n     * and callback `fn` containing nested suites\r\n     * and/or tests.\r\n     */\r\n\r\n    context.describe = context.context = function(title, fn){\r\n      var suite = Suite.create(suites[0], title);\r\n      suites.unshift(suite);\r\n      fn.call(suite);\r\n      suites.shift();\r\n      return suite;\r\n    };\r\n\r\n    /**\r\n     * Pending describe.\r\n     */\r\n\r\n    context.xdescribe =\r\n    context.xcontext =\r\n    context.describe.skip = function(title, fn){\r\n      var suite = Suite.create(suites[0], title);\r\n      suite.pending = true;\r\n      suites.unshift(suite);\r\n      fn.call(suite);\r\n      suites.shift();\r\n    };\r\n\r\n    /**\r\n     * Exclusive suite.\r\n     */\r\n\r\n    context.describe.only = function(title, fn){\r\n      var suite = context.describe(title, fn);\r\n      mocha.grep(suite.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.it = context.specify = function(title, fn){\r\n      var suite = suites[0];\r\n      if (suite.pending) var fn = null;\r\n      var test = new Test(title, fn);\r\n      suite.addTest(test);\r\n      return test;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.it.only = function(title, fn){\r\n      var test = context.it(title, fn);\r\n      mocha.grep(test.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Pending test case.\r\n     */\r\n\r\n    context.xit =\r\n    context.xspecify =\r\n    context.it.skip = function(title){\r\n      context.it(title);\r\n    };\r\n  });\r\n};\r\n\r\n}); // module: interfaces/bdd.js\r\n\r\nrequire.register(\"interfaces/exports.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * TDD-style interface:\r\n *\r\n *     exports.Array = {\r\n *       '#indexOf()': {\r\n *         'should return -1 when the value is not present': function(){\r\n *\r\n *         },\r\n *\r\n *         'should return the correct index when the value is present': function(){\r\n *\r\n *         }\r\n *       }\r\n *     };\r\n *\r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('require', visit);\r\n\r\n  function visit(obj) {\r\n    var suite;\r\n    for (var key in obj) {\r\n      if ('function' == typeof obj[key]) {\r\n        var fn = obj[key];\r\n        switch (key) {\r\n          case 'before':\r\n            suites[0].beforeAll(fn);\r\n            break;\r\n          case 'after':\r\n            suites[0].afterAll(fn);\r\n            break;\r\n          case 'beforeEach':\r\n            suites[0].beforeEach(fn);\r\n            break;\r\n          case 'afterEach':\r\n            suites[0].afterEach(fn);\r\n            break;\r\n          default:\r\n            suites[0].addTest(new Test(key, fn));\r\n        }\r\n      } else {\r\n        var suite = Suite.create(suites[0], key);\r\n        suites.unshift(suite);\r\n        visit(obj[key]);\r\n        suites.shift();\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n}); // module: interfaces/exports.js\r\n\r\nrequire.register(\"interfaces/index.js\", function(module, exports, require){\r\n\r\nexports.bdd = require('./bdd');\r\nexports.tdd = require('./tdd');\r\nexports.qunit = require('./qunit');\r\nexports.exports = require('./exports');\r\n\r\n}); // module: interfaces/index.js\r\n\r\nrequire.register(\"interfaces/qunit.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * QUnit-style interface:\r\n *\r\n *     suite('Array');\r\n *\r\n *     test('#length', function(){\r\n *       var arr = [1,2,3];\r\n *       ok(arr.length == 3);\r\n *     });\r\n *\r\n *     test('#indexOf()', function(){\r\n *       var arr = [1,2,3];\r\n *       ok(arr.indexOf(1) == 0);\r\n *       ok(arr.indexOf(2) == 1);\r\n *       ok(arr.indexOf(3) == 2);\r\n *     });\r\n *\r\n *     suite('String');\r\n *\r\n *     test('#length', function(){\r\n *       ok('foo'.length == 3);\r\n *     });\r\n *\r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('pre-require', function(context){\r\n\r\n    /**\r\n     * Execute before running tests.\r\n     */\r\n\r\n    context.before = function(fn){\r\n      suites[0].beforeAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after running tests.\r\n     */\r\n\r\n    context.after = function(fn){\r\n      suites[0].afterAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute before each test case.\r\n     */\r\n\r\n    context.beforeEach = function(fn){\r\n      suites[0].beforeEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after each test case.\r\n     */\r\n\r\n    context.afterEach = function(fn){\r\n      suites[0].afterEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Describe a \"suite\" with the given `title`.\r\n     */\r\n\r\n    context.suite = function(title){\r\n      if (suites.length > 1) suites.shift();\r\n      var suite = Suite.create(suites[0], title);\r\n      suites.unshift(suite);\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.test = function(title, fn){\r\n      suites[0].addTest(new Test(title, fn));\r\n    };\r\n  });\r\n};\r\n\r\n}); // module: interfaces/qunit.js\r\n\r\nrequire.register(\"interfaces/tdd.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * TDD-style interface:\r\n *\r\n *      suite('Array', function(){\r\n *        suite('#indexOf()', function(){\r\n *          suiteSetup(function(){\r\n *\r\n *          });\r\n *\r\n *          test('should return -1 when not present', function(){\r\n *\r\n *          });\r\n *\r\n *          test('should return the index when present', function(){\r\n *\r\n *          });\r\n *\r\n *          suiteTeardown(function(){\r\n *\r\n *          });\r\n *        });\r\n *      });\r\n *\r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('pre-require', function(context, file, mocha){\r\n\r\n    /**\r\n     * Execute before each test case.\r\n     */\r\n\r\n    context.setup = function(fn){\r\n      suites[0].beforeEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after each test case.\r\n     */\r\n\r\n    context.teardown = function(fn){\r\n      suites[0].afterEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute before the suite.\r\n     */\r\n\r\n    context.suiteSetup = function(fn){\r\n      suites[0].beforeAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after the suite.\r\n     */\r\n\r\n    context.suiteTeardown = function(fn){\r\n      suites[0].afterAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Describe a \"suite\" with the given `title`\r\n     * and callback `fn` containing nested suites\r\n     * and/or tests.\r\n     */\r\n\r\n    context.suite = function(title, fn){\r\n      var suite = Suite.create(suites[0], title);\r\n      suites.unshift(suite);\r\n      fn.call(suite);\r\n      suites.shift();\r\n      return suite;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.suite.only = function(title, fn){\r\n      var suite = context.suite(title, fn);\r\n      mocha.grep(suite.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.test = function(title, fn){\r\n      var test = new Test(title, fn);\r\n      suites[0].addTest(test);\r\n      return test;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.test.only = function(title, fn){\r\n      var test = context.test(title, fn);\r\n      mocha.grep(test.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Pending test case.\r\n     */\r\n\r\n    context.test.skip = function(title){\r\n      context.test(title);\r\n    };\r\n  });\r\n};\r\n\r\n}); // module: interfaces/tdd.js\r\n\r\nrequire.register(\"mocha.js\", function(module, exports, require){\r\n/*!\r\n * mocha\r\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar path = require('browser/path')\r\n  , utils = require('./utils');\r\n\r\n/**\r\n * Expose `Mocha`.\r\n */\r\n\r\nexports = module.exports = Mocha;\r\n\r\n/**\r\n * Expose internals.\r\n */\r\n\r\nexports.utils = utils;\r\nexports.interfaces = require('./interfaces');\r\nexports.reporters = require('./reporters');\r\nexports.Runnable = require('./runnable');\r\nexports.Context = require('./context');\r\nexports.Runner = require('./runner');\r\nexports.Suite = require('./suite');\r\nexports.Hook = require('./hook');\r\nexports.Test = require('./test');\r\n\r\n/**\r\n * Return image `name` path.\r\n *\r\n * @param {String} name\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction image(name) {\r\n  return __dirname + '/../images/' + name + '.png';\r\n}\r\n\r\n/**\r\n * Setup mocha with `options`.\r\n *\r\n * Options:\r\n *\r\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\r\n *   - `reporter` reporter instance, defaults to `mocha.reporters.Dot`\r\n *   - `globals` array of accepted globals\r\n *   - `timeout` timeout in milliseconds\r\n *   - `bail` bail on the first test failure\r\n *   - `slow` milliseconds to wait before considering a test slow\r\n *   - `ignoreLeaks` ignore global leaks\r\n *   - `grep` string or regexp to filter tests with\r\n *\r\n * @param {Object} options\r\n * @api public\r\n */\r\n\r\nfunction Mocha(options) {\r\n  options = options || {};\r\n  this.files = [];\r\n  this.options = options;\r\n  this.grep(options.grep);\r\n  this.suite = new exports.Suite('', new exports.Context);\r\n  this.ui(options.ui);\r\n  this.bail(options.bail);\r\n  this.reporter(options.reporter);\r\n  if (options.timeout) this.timeout(options.timeout);\r\n  if (options.slow) this.slow(options.slow);\r\n}\r\n\r\n/**\r\n * Enable or disable bailing on the first failure.\r\n *\r\n * @param {Boolean} [bail]\r\n * @api public\r\n */\r\n\r\nMocha.prototype.bail = function(bail){\r\n  if (0 == arguments.length) bail = true;\r\n  this.suite.bail(bail);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add test `file`.\r\n *\r\n * @param {String} file\r\n * @api public\r\n */\r\n\r\nMocha.prototype.addFile = function(file){\r\n  this.files.push(file);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set reporter to `reporter`, defaults to \"dot\".\r\n *\r\n * @param {String|Function} reporter name or constructor\r\n * @api public\r\n */\r\n\r\nMocha.prototype.reporter = function(reporter){\r\n  if ('function' == typeof reporter) {\r\n    this._reporter = reporter;\r\n  } else {\r\n    reporter = reporter || 'dot';\r\n    try {\r\n      this._reporter = require('./reporters/' + reporter);\r\n    } catch (err) {\r\n      this._reporter = require(reporter);\r\n    }\r\n    if (!this._reporter) throw new Error('invalid reporter \"' + reporter + '\"');\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set test UI `name`, defaults to \"bdd\".\r\n *\r\n * @param {String} bdd\r\n * @api public\r\n */\r\n\r\nMocha.prototype.ui = function(name){\r\n  name = name || 'bdd';\r\n  this._ui = exports.interfaces[name];\r\n  if (!this._ui) throw new Error('invalid interface \"' + name + '\"');\r\n  this._ui = this._ui(this.suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Load registered files.\r\n *\r\n * @api private\r\n */\r\n\r\nMocha.prototype.loadFiles = function(fn){\r\n  var self = this;\r\n  var suite = this.suite;\r\n  var pending = this.files.length;\r\n  this.files.forEach(function(file){\r\n    file = path.resolve(file);\r\n    suite.emit('pre-require', global, file, self);\r\n    suite.emit('require', require(file), file, self);\r\n    suite.emit('post-require', global, file, self);\r\n    --pending || (fn && fn());\r\n  });\r\n};\r\n\r\n/**\r\n * Enable growl support.\r\n *\r\n * @api private\r\n */\r\n\r\nMocha.prototype._growl = function(runner, reporter) {\r\n  var notify = require('growl');\r\n\r\n  runner.on('end', function(){\r\n    var stats = reporter.stats;\r\n    if (stats.failures) {\r\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\r\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\r\n    } else {\r\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\r\n          name: 'mocha'\r\n        , title: 'Passed'\r\n        , image: image('ok')\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Add regexp to grep, if `re` is a string it is escaped.\r\n *\r\n * @param {RegExp|String} re\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.grep = function(re){\r\n  this.options.grep = 'string' == typeof re\r\n    ? new RegExp(utils.escapeRegexp(re))\r\n    : re;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Invert `.grep()` matches.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.invert = function(){\r\n  this.options.invert = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Ignore global leaks.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.ignoreLeaks = function(){\r\n  this.options.ignoreLeaks = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enable global leak checking.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.checkLeaks = function(){\r\n  this.options.ignoreLeaks = false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enable growl support.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.growl = function(){\r\n  this.options.growl = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Ignore `globals` array or string.\r\n *\r\n * @param {Array|String} globals\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.globals = function(globals){\r\n  this.options.globals = (this.options.globals || []).concat(globals);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the timeout in milliseconds.\r\n *\r\n * @param {Number} timeout\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.timeout = function(timeout){\r\n  this.suite.timeout(timeout);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set slowness threshold in milliseconds.\r\n *\r\n * @param {Number} slow\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.slow = function(slow){\r\n  this.suite.slow(slow);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Makes all tests async (accepting a callback)\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.asyncOnly = function(){\r\n  this.options.asyncOnly = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run tests and invoke `fn()` when complete.\r\n *\r\n * @param {Function} fn\r\n * @return {Runner}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.run = function(fn){\r\n  if (this.files.length) this.loadFiles();\r\n  var suite = this.suite;\r\n  var options = this.options;\r\n  var runner = new exports.Runner(suite);\r\n  var reporter = new this._reporter(runner);\r\n  runner.ignoreLeaks = false !== options.ignoreLeaks;\r\n  runner.asyncOnly = options.asyncOnly;\r\n  if (options.grep) runner.grep(options.grep, options.invert);\r\n  if (options.globals) runner.globals(options.globals);\r\n  if (options.growl) this._growl(runner, reporter);\r\n  return runner.run(fn);\r\n};\r\n\r\n}); // module: mocha.js\r\n\r\nrequire.register(\"ms.js\", function(module, exports, require){\r\n\r\n/**\r\n * Helpers.\r\n */\r\n\r\nvar s = 1000;\r\nvar m = s * 60;\r\nvar h = m * 60;\r\nvar d = h * 24;\r\n\r\n/**\r\n * Parse or format the given `val`.\r\n *\r\n * @param {String|Number} val\r\n * @return {String|Number}\r\n * @api public\r\n */\r\n\r\nmodule.exports = function(val){\r\n  if ('string' == typeof val) return parse(val);\r\n  return format(val);\r\n}\r\n\r\n/**\r\n * Parse the given `str` and return milliseconds.\r\n *\r\n * @param {String} str\r\n * @return {Number}\r\n * @api private\r\n */\r\n\r\nfunction parse(str) {\r\n  var m = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\r\n  if (!m) return;\r\n  var n = parseFloat(m[1]);\r\n  var type = (m[2] || 'ms').toLowerCase();\r\n  switch (type) {\r\n    case 'years':\r\n    case 'year':\r\n    case 'y':\r\n      return n * 31557600000;\r\n    case 'days':\r\n    case 'day':\r\n    case 'd':\r\n      return n * 86400000;\r\n    case 'hours':\r\n    case 'hour':\r\n    case 'h':\r\n      return n * 3600000;\r\n    case 'minutes':\r\n    case 'minute':\r\n    case 'm':\r\n      return n * 60000;\r\n    case 'seconds':\r\n    case 'second':\r\n    case 's':\r\n      return n * 1000;\r\n    case 'ms':\r\n      return n;\r\n  }\r\n}\r\n\r\n/**\r\n * Format the given `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nfunction format(ms) {\r\n  if (ms == d) return Math.round(ms / d) + ' day';\r\n  if (ms > d) return Math.round(ms / d) + ' days';\r\n  if (ms == h) return Math.round(ms / h) + ' hour';\r\n  if (ms > h) return Math.round(ms / h) + ' hours';\r\n  if (ms == m) return Math.round(ms / m) + ' minute';\r\n  if (ms > m) return Math.round(ms / m) + ' minutes';\r\n  if (ms == s) return Math.round(ms / s) + ' second';\r\n  if (ms > s) return Math.round(ms / s) + ' seconds';\r\n  return ms + ' ms';\r\n}\r\n}); // module: ms.js\r\n\r\nrequire.register(\"reporters/base.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar tty = require('browser/tty')\r\n  , diff = require('browser/diff')\r\n  , ms = require('../ms');\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Check if both stdio streams are associated with a tty.\r\n */\r\n\r\nvar isatty = tty.isatty(1) && tty.isatty(2);\r\n\r\n/**\r\n * Expose `Base`.\r\n */\r\n\r\nexports = module.exports = Base;\r\n\r\n/**\r\n * Enable coloring by default.\r\n */\r\n\r\nexports.useColors = isatty;\r\n\r\n/**\r\n * Default color map.\r\n */\r\n\r\nexports.colors = {\r\n    'pass': 90\r\n  , 'fail': 31\r\n  , 'bright pass': 92\r\n  , 'bright fail': 91\r\n  , 'bright yellow': 93\r\n  , 'pending': 36\r\n  , 'suite': 0\r\n  , 'error title': 0\r\n  , 'error message': 31\r\n  , 'error stack': 90\r\n  , 'checkmark': 32\r\n  , 'fast': 90\r\n  , 'medium': 33\r\n  , 'slow': 31\r\n  , 'green': 32\r\n  , 'light': 90\r\n  , 'diff gutter': 90\r\n  , 'diff added': 42\r\n  , 'diff removed': 41\r\n};\r\n\r\n/**\r\n * Default symbol map.\r\n */\r\n\r\nexports.symbols = {\r\n  ok: '✓',\r\n  err: '✖',\r\n  dot: '․'\r\n};\r\n\r\n// With node.js on Windows: use symbols available in terminal default fonts\r\nif ('win32' == process.platform) {\r\n  exports.symbols.ok = '\\u221A';\r\n  exports.symbols.err = '\\u00D7';\r\n  exports.symbols.dot = '.';\r\n}\r\n\r\n/**\r\n * Color `str` with the given `type`,\r\n * allowing colors to be disabled,\r\n * as well as user-defined color\r\n * schemes.\r\n *\r\n * @param {String} type\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nvar color = exports.color = function(type, str) {\r\n  if (!exports.useColors) return str;\r\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\r\n};\r\n\r\n/**\r\n * Expose term window size, with some\r\n * defaults for when stderr is not a tty.\r\n */\r\n\r\nexports.window = {\r\n  width: isatty\r\n    ? process.stdout.getWindowSize\r\n      ? process.stdout.getWindowSize(1)[0]\r\n      : tty.getWindowSize()[1]\r\n    : 75\r\n};\r\n\r\n/**\r\n * Expose some basic cursor interactions\r\n * that are common among reporters.\r\n */\r\n\r\nexports.cursor = {\r\n  hide: function(){\r\n    process.stdout.write('\\u001b[?25l');\r\n  },\r\n\r\n  show: function(){\r\n    process.stdout.write('\\u001b[?25h');\r\n  },\r\n\r\n  deleteLine: function(){\r\n    process.stdout.write('\\u001b[2K');\r\n  },\r\n\r\n  beginningOfLine: function(){\r\n    process.stdout.write('\\u001b[0G');\r\n  },\r\n\r\n  CR: function(){\r\n    exports.cursor.deleteLine();\r\n    exports.cursor.beginningOfLine();\r\n  }\r\n};\r\n\r\n/**\r\n * Outut the given `failures` as a list.\r\n *\r\n * @param {Array} failures\r\n * @api public\r\n */\r\n\r\nexports.list = function(failures){\r\n  console.error();\r\n  failures.forEach(function(test, i){\r\n    // format\r\n    var fmt = color('error title', '  %s) %s:\\n')\r\n      + color('error message', '     %s')\r\n      + color('error stack', '\\n%s\\n');\r\n\r\n    // msg\r\n    var err = test.err\r\n      , message = err.message || ''\r\n      , stack = err.stack || message\r\n      , index = stack.indexOf(message) + message.length\r\n      , msg = stack.slice(0, index)\r\n      , actual = err.actual\r\n      , expected = err.expected\r\n      , escape = true;\r\n\r\n    // explicitly show diff\r\n    if (err.showDiff) {\r\n      escape = false;\r\n      err.actual = actual = JSON.stringify(actual, null, 2);\r\n      err.expected = expected = JSON.stringify(expected, null, 2);\r\n    }\r\n\r\n    // actual / expected diff\r\n    if ('string' == typeof actual && 'string' == typeof expected) {\r\n      var len = Math.max(actual.length, expected.length);\r\n\r\n      if (len < 20) msg = errorDiff(err, 'Chars', escape);\r\n      else msg = errorDiff(err, 'Words', escape);\r\n\r\n      // linenos\r\n      var lines = msg.split('\\n');\r\n      if (lines.length > 4) {\r\n        var width = String(lines.length).length;\r\n        msg = lines.map(function(str, i){\r\n          return pad(++i, width) + ' |' + ' ' + str;\r\n        }).join('\\n');\r\n      }\r\n\r\n      // legend\r\n      msg = '\\n'\r\n        + color('diff removed', 'actual')\r\n        + ' '\r\n        + color('diff added', 'expected')\r\n        + '\\n\\n'\r\n        + msg\r\n        + '\\n';\r\n\r\n      // indent\r\n      msg = msg.replace(/^/gm, '      ');\r\n\r\n      fmt = color('error title', '  %s) %s:\\n%s')\r\n        + color('error stack', '\\n%s\\n');\r\n    }\r\n\r\n    // indent stack trace without msg\r\n    stack = stack.slice(index ? index + 1 : index)\r\n      .replace(/^/gm, '  ');\r\n\r\n    console.error(fmt, (i + 1), test.fullTitle(), msg, stack);\r\n  });\r\n};\r\n\r\n/**\r\n * Initialize a new `Base` reporter.\r\n *\r\n * All other reporters generally\r\n * inherit from this reporter, providing\r\n * stats such as test duration, number\r\n * of tests passed / failed etc.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Base(runner) {\r\n  var self = this\r\n    , stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 }\r\n    , failures = this.failures = [];\r\n\r\n  if (!runner) return;\r\n  this.runner = runner;\r\n\r\n  runner.stats = stats;\r\n\r\n  runner.on('start', function(){\r\n    stats.start = new Date;\r\n  });\r\n\r\n  runner.on('suite', function(suite){\r\n    stats.suites = stats.suites || 0;\r\n    suite.root || stats.suites++;\r\n  });\r\n\r\n  runner.on('test end', function(test){\r\n    stats.tests = stats.tests || 0;\r\n    stats.tests++;\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    stats.passes = stats.passes || 0;\r\n\r\n    var medium = test.slow() / 2;\r\n    test.speed = test.duration > test.slow()\r\n      ? 'slow'\r\n      : test.duration > medium\r\n        ? 'medium'\r\n        : 'fast';\r\n\r\n    stats.passes++;\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    stats.failures = stats.failures || 0;\r\n    stats.failures++;\r\n    test.err = err;\r\n    failures.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    stats.end = new Date;\r\n    stats.duration = new Date - stats.start;\r\n  });\r\n\r\n  runner.on('pending', function(){\r\n    stats.pending++;\r\n  });\r\n}\r\n\r\n/**\r\n * Output common epilogue used by many of\r\n * the bundled reporters.\r\n *\r\n * @api public\r\n */\r\n\r\nBase.prototype.epilogue = function(){\r\n  var stats = this.stats\r\n    , fmt\r\n    , tests;\r\n\r\n  console.log();\r\n\r\n  function pluralize(n) {\r\n    return 1 == n ? 'test' : 'tests';\r\n  }\r\n\r\n  // failure\r\n  if (stats.failures) {\r\n    fmt = color('bright fail', '  ' + exports.symbols.err)\r\n      + color('fail', ' %d of %d %s failed')\r\n      + color('light', ':')\r\n\r\n    console.error(fmt,\r\n      stats.failures,\r\n      this.runner.total,\r\n      pluralize(this.runner.total));\r\n\r\n    Base.list(this.failures);\r\n    console.error();\r\n    return;\r\n  }\r\n\r\n  // pass\r\n  fmt = color('bright pass', ' ')\r\n    + color('green', ' %d %s complete')\r\n    + color('light', ' (%s)');\r\n\r\n  console.log(fmt,\r\n    stats.tests || 0,\r\n    pluralize(stats.tests),\r\n    ms(stats.duration));\r\n\r\n  // pending\r\n  if (stats.pending) {\r\n    fmt = color('pending', ' ')\r\n      + color('pending', ' %d %s pending');\r\n\r\n    console.log(fmt, stats.pending, pluralize(stats.pending));\r\n  }\r\n\r\n  console.log();\r\n};\r\n\r\n/**\r\n * Pad the given `str` to `len`.\r\n *\r\n * @param {String} str\r\n * @param {String} len\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction pad(str, len) {\r\n  str = String(str);\r\n  return Array(len - str.length + 1).join(' ') + str;\r\n}\r\n\r\n/**\r\n * Return a character diff for `err`.\r\n *\r\n * @param {Error} err\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction errorDiff(err, type, escape) {\r\n  return diff['diff' + type](err.actual, err.expected).map(function(str){\r\n    if (escape) {\r\n      str.value = str.value\r\n        .replace(/\\t/g, '<tab>')\r\n        .replace(/\\r/g, '<CR>')\r\n        .replace(/\\n/g, '<LF>\\n');\r\n    }\r\n    if (str.added) return colorLines('diff added', str.value);\r\n    if (str.removed) return colorLines('diff removed', str.value);\r\n    return str.value;\r\n  }).join('');\r\n}\r\n\r\n/**\r\n * Color lines for `str`, using the color `name`.\r\n *\r\n * @param {String} name\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction colorLines(name, str) {\r\n  return str.split('\\n').map(function(str){\r\n    return color(name, str);\r\n  }).join('\\n');\r\n}\r\n\r\n}); // module: reporters/base.js\r\n\r\nrequire.register(\"reporters/doc.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils');\r\n\r\n/**\r\n * Expose `Doc`.\r\n */\r\n\r\nexports = module.exports = Doc;\r\n\r\n/**\r\n * Initialize a new `Doc` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Doc(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , total = runner.total\r\n    , indents = 2;\r\n\r\n  function indent() {\r\n    return Array(indents).join('  ');\r\n  }\r\n\r\n  runner.on('suite', function(suite){\r\n    if (suite.root) return;\r\n    ++indents;\r\n    console.log('%s<section class=\"suite\">', indent());\r\n    ++indents;\r\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\r\n    console.log('%s<dl>', indent());\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    if (suite.root) return;\r\n    console.log('%s</dl>', indent());\r\n    --indents;\r\n    console.log('%s</section>', indent());\r\n    --indents;\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\r\n    var code = utils.escape(utils.clean(test.fn.toString()));\r\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\r\n  });\r\n}\r\n\r\n}); // module: reporters/doc.js\r\n\r\nrequire.register(\"reporters/dot.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Dot`.\r\n */\r\n\r\nexports = module.exports = Dot;\r\n\r\n/**\r\n * Initialize a new `Dot` matrix test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Dot(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , width = Base.window.width * .75 | 0\r\n    , n = 0;\r\n\r\n  runner.on('start', function(){\r\n    process.stdout.write('\\n  ');\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    process.stdout.write(color('pending', Base.symbols.dot));\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    if (++n % width == 0) process.stdout.write('\\n  ');\r\n    if ('slow' == test.speed) {\r\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\r\n    } else {\r\n      process.stdout.write(color(test.speed, Base.symbols.dot));\r\n    }\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    if (++n % width == 0) process.stdout.write('\\n  ');\r\n    process.stdout.write(color('fail', Base.symbols.dot));\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    console.log();\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nDot.prototype = new F;\r\nDot.prototype.constructor = Dot;\r\n\r\n}); // module: reporters/dot.js\r\n\r\nrequire.register(\"reporters/html-cov.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar JSONCov = require('./json-cov')\r\n  , fs = require('browser/fs');\r\n\r\n/**\r\n * Expose `HTMLCov`.\r\n */\r\n\r\nexports = module.exports = HTMLCov;\r\n\r\n/**\r\n * Initialize a new `JsCoverage` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction HTMLCov(runner) {\r\n  var jade = require('jade')\r\n    , file = __dirname + '/templates/coverage.jade'\r\n    , str = fs.readFileSync(file, 'utf8')\r\n    , fn = jade.compile(str, { filename: file })\r\n    , self = this;\r\n\r\n  JSONCov.call(this, runner, false);\r\n\r\n  runner.on('end', function(){\r\n    process.stdout.write(fn({\r\n        cov: self.cov\r\n      , coverageClass: coverageClass\r\n    }));\r\n  });\r\n}\r\n\r\n/**\r\n * Return coverage class for `n`.\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction coverageClass(n) {\r\n  if (n >= 75) return 'high';\r\n  if (n >= 50) return 'medium';\r\n  if (n >= 25) return 'low';\r\n  return 'terrible';\r\n}\r\n}); // module: reporters/html-cov.js\r\n\r\nrequire.register(\"reporters/html.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils')\r\n  , Progress = require('../browser/progress')\r\n  , escape = utils.escape;\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Expose `Doc`.\r\n */\r\n\r\nexports = module.exports = HTML;\r\n\r\n/**\r\n * Stats template.\r\n */\r\n\r\nvar statsTemplate = '<ul id=\"mocha-stats\">'\r\n  + '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>'\r\n  + '<li class=\"passes\"><a href=\"#\">passes:</a> <em>0</em></li>'\r\n  + '<li class=\"failures\"><a href=\"#\">failures:</a> <em>0</em></li>'\r\n  + '<li class=\"duration\">duration: <em>0</em>s</li>'\r\n  + '</ul>';\r\n\r\n/**\r\n * Initialize a new `Doc` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction HTML(runner, root) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , total = runner.total\r\n    , stat = fragment(statsTemplate)\r\n    , items = stat.getElementsByTagName('li')\r\n    , passes = items[1].getElementsByTagName('em')[0]\r\n    , passesLink = items[1].getElementsByTagName('a')[0]\r\n    , failures = items[2].getElementsByTagName('em')[0]\r\n    , failuresLink = items[2].getElementsByTagName('a')[0]\r\n    , duration = items[3].getElementsByTagName('em')[0]\r\n    , canvas = stat.getElementsByTagName('canvas')[0]\r\n    , report = fragment('<ul id=\"mocha-report\"></ul>')\r\n    , stack = [report]\r\n    , progress\r\n    , ctx\r\n\r\n  root = root || document.getElementById('mocha');\r\n\r\n  if (canvas.getContext) {\r\n    var ratio = window.devicePixelRatio || 1;\r\n    canvas.style.width = canvas.width;\r\n    canvas.style.height = canvas.height;\r\n    canvas.width *= ratio;\r\n    canvas.height *= ratio;\r\n    ctx = canvas.getContext('2d');\r\n    ctx.scale(ratio, ratio);\r\n    progress = new Progress;\r\n  }\r\n\r\n  if (!root) return error('#mocha div missing, add it to your document');\r\n\r\n  // pass toggle\r\n  on(passesLink, 'click', function(){\r\n    unhide();\r\n    var name = /pass/.test(report.className) ? '' : ' pass';\r\n    report.className = report.className.replace(/fail|pass/g, '') + name;\r\n    if (report.className.trim()) hideSuitesWithout('test pass');\r\n  });\r\n\r\n  // failure toggle\r\n  on(failuresLink, 'click', function(){\r\n    unhide();\r\n    var name = /fail/.test(report.className) ? '' : ' fail';\r\n    report.className = report.className.replace(/fail|pass/g, '') + name;\r\n    if (report.className.trim()) hideSuitesWithout('test fail');\r\n  });\r\n\r\n  root.appendChild(stat);\r\n  root.appendChild(report);\r\n\r\n  if (progress) progress.size(40);\r\n\r\n  runner.on('suite', function(suite){\r\n    if (suite.root) return;\r\n\r\n    // suite\r\n    var url = '?grep=' + encodeURIComponent(suite.fullTitle());\r\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\r\n\r\n    // container\r\n    stack[0].appendChild(el);\r\n    stack.unshift(document.createElement('ul'));\r\n    el.appendChild(stack[0]);\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    if (suite.root) return;\r\n    stack.shift();\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    if ('hook' == test.type) runner.emit('test end', test);\r\n  });\r\n\r\n  runner.on('test end', function(test){\r\n    // TODO: add to stats\r\n    var percent = stats.tests / this.total * 100 | 0;\r\n    if (progress) progress.update(percent).draw(ctx);\r\n\r\n    // update stats\r\n    var ms = new Date - stats.start;\r\n    text(passes, stats.passes);\r\n    text(failures, stats.failures);\r\n    text(duration, (ms / 1000).toFixed(2));\r\n\r\n    // test\r\n    if ('passed' == test.state) {\r\n      var el = fragment('<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> <a href=\"?grep=%e\" class=\"replay\">‣</a></h2></li>', test.speed, test.title, test.duration, encodeURIComponent(test.fullTitle()));\r\n    } else if (test.pending) {\r\n      var el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\r\n    } else {\r\n      var el = fragment('<li class=\"test fail\"><h2>%e <a href=\"?grep=%e\" class=\"replay\">‣</a></h2></li>', test.title, encodeURIComponent(test.fullTitle()));\r\n      var str = test.err.stack || test.err.toString();\r\n\r\n      // FF / Opera do not add the message\r\n      if (!~str.indexOf(test.err.message)) {\r\n        str = test.err.message + '\\n' + str;\r\n      }\r\n\r\n      // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\r\n      // check for the result of the stringifying.\r\n      if ('[object Error]' == str) str = test.err.message;\r\n\r\n      // Safari doesn't give you a stack. Let's at least provide a source line.\r\n      if (!test.err.stack && test.err.sourceURL && test.err.line !== undefined) {\r\n        str += \"\\n(\" + test.err.sourceURL + \":\" + test.err.line + \")\";\r\n      }\r\n\r\n      el.appendChild(fragment('<pre class=\"error\">%e</pre>', str));\r\n    }\r\n\r\n    // toggle code\r\n    // TODO: defer\r\n    if (!test.pending) {\r\n      var h2 = el.getElementsByTagName('h2')[0];\r\n\r\n      on(h2, 'click', function(){\r\n        pre.style.display = 'none' == pre.style.display\r\n          ? 'block'\r\n          : 'none';\r\n      });\r\n\r\n      var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.fn.toString()));\r\n      el.appendChild(pre);\r\n      pre.style.display = 'none';\r\n    }\r\n\r\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\r\n    if (stack[0]) stack[0].appendChild(el);\r\n  });\r\n}\r\n\r\n/**\r\n * Display error `msg`.\r\n */\r\n\r\nfunction error(msg) {\r\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\r\n}\r\n\r\n/**\r\n * Return a DOM fragment from `html`.\r\n */\r\n\r\nfunction fragment(html) {\r\n  var args = arguments\r\n    , div = document.createElement('div')\r\n    , i = 1;\r\n\r\n  div.innerHTML = html.replace(/%([se])/g, function(_, type){\r\n    switch (type) {\r\n      case 's': return String(args[i++]);\r\n      case 'e': return escape(args[i++]);\r\n    }\r\n  });\r\n\r\n  return div.firstChild;\r\n}\r\n\r\n/**\r\n * Check for suites that do not have elements\r\n * with `classname`, and hide them.\r\n */\r\n\r\nfunction hideSuitesWithout(classname) {\r\n  var suites = document.getElementsByClassName('suite');\r\n  for (var i = 0; i < suites.length; i++) {\r\n    var els = suites[i].getElementsByClassName(classname);\r\n    if (0 == els.length) suites[i].className += ' hidden';\r\n  }\r\n}\r\n\r\n/**\r\n * Unhide .hidden suites.\r\n */\r\n\r\nfunction unhide() {\r\n  var els = document.getElementsByClassName('suite hidden');\r\n  for (var i = 0; i < els.length; ++i) {\r\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\r\n  }\r\n}\r\n\r\n/**\r\n * Set `el` text to `str`.\r\n */\r\n\r\nfunction text(el, str) {\r\n  if (el.textContent) {\r\n    el.textContent = str;\r\n  } else {\r\n    el.innerText = str;\r\n  }\r\n}\r\n\r\n/**\r\n * Listen on `event` with callback `fn`.\r\n */\r\n\r\nfunction on(el, event, fn) {\r\n  if (el.addEventListener) {\r\n    el.addEventListener(event, fn, false);\r\n  } else {\r\n    el.attachEvent('on' + event, fn);\r\n  }\r\n}\r\n\r\n}); // module: reporters/html.js\r\n\r\nrequire.register(\"reporters/index.js\", function(module, exports, require){\r\n\r\nexports.Base = require('./base');\r\nexports.Dot = require('./dot');\r\nexports.Doc = require('./doc');\r\nexports.TAP = require('./tap');\r\nexports.JSON = require('./json');\r\nexports.HTML = require('./html');\r\nexports.List = require('./list');\r\nexports.Min = require('./min');\r\nexports.Spec = require('./spec');\r\nexports.Nyan = require('./nyan');\r\nexports.XUnit = require('./xunit');\r\nexports.Markdown = require('./markdown');\r\nexports.Progress = require('./progress');\r\nexports.Landing = require('./landing');\r\nexports.JSONCov = require('./json-cov');\r\nexports.HTMLCov = require('./html-cov');\r\nexports.JSONStream = require('./json-stream');\r\nexports.Teamcity = require('./teamcity');\r\n\r\n}); // module: reporters/index.js\r\n\r\nrequire.register(\"reporters/json-cov.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base');\r\n\r\n/**\r\n * Expose `JSONCov`.\r\n */\r\n\r\nexports = module.exports = JSONCov;\r\n\r\n/**\r\n * Initialize a new `JsCoverage` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @param {Boolean} output\r\n * @api public\r\n */\r\n\r\nfunction JSONCov(runner, output) {\r\n  var self = this\r\n    , output = 1 == arguments.length ? true : output;\r\n\r\n  Base.call(this, runner);\r\n\r\n  var tests = []\r\n    , failures = []\r\n    , passes = [];\r\n\r\n  runner.on('test end', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    passes.push(test);\r\n  });\r\n\r\n  runner.on('fail', function(test){\r\n    failures.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    var cov = global._$jscoverage || {};\r\n    var result = self.cov = map(cov);\r\n    result.stats = self.stats;\r\n    result.tests = tests.map(clean);\r\n    result.failures = failures.map(clean);\r\n    result.passes = passes.map(clean);\r\n    if (!output) return;\r\n    process.stdout.write(JSON.stringify(result, null, 2 ));\r\n  });\r\n}\r\n\r\n/**\r\n * Map jscoverage data to a JSON structure\r\n * suitable for reporting.\r\n *\r\n * @param {Object} cov\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction map(cov) {\r\n  var ret = {\r\n      instrumentation: 'node-jscoverage'\r\n    , sloc: 0\r\n    , hits: 0\r\n    , misses: 0\r\n    , coverage: 0\r\n    , files: []\r\n  };\r\n\r\n  for (var filename in cov) {\r\n    var data = coverage(filename, cov[filename]);\r\n    ret.files.push(data);\r\n    ret.hits += data.hits;\r\n    ret.misses += data.misses;\r\n    ret.sloc += data.sloc;\r\n  }\r\n\r\n  ret.files.sort(function(a, b) {\r\n    return a.filename.localeCompare(b.filename);\r\n  });\r\n\r\n  if (ret.sloc > 0) {\r\n    ret.coverage = (ret.hits / ret.sloc) * 100;\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Map jscoverage data for a single source file\r\n * to a JSON structure suitable for reporting.\r\n *\r\n * @param {String} filename name of the source file\r\n * @param {Object} data jscoverage coverage data\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction coverage(filename, data) {\r\n  var ret = {\r\n    filename: filename,\r\n    coverage: 0,\r\n    hits: 0,\r\n    misses: 0,\r\n    sloc: 0,\r\n    source: {}\r\n  };\r\n\r\n  data.source.forEach(function(line, num){\r\n    num++;\r\n\r\n    if (data[num] === 0) {\r\n      ret.misses++;\r\n      ret.sloc++;\r\n    } else if (data[num] !== undefined) {\r\n      ret.hits++;\r\n      ret.sloc++;\r\n    }\r\n\r\n    ret.source[num] = {\r\n        source: line\r\n      , coverage: data[num] === undefined\r\n        ? ''\r\n        : data[num]\r\n    };\r\n  });\r\n\r\n  ret.coverage = ret.hits / ret.sloc * 100;\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Return a plain-object representation of `test`\r\n * free of cyclic properties etc.\r\n *\r\n * @param {Object} test\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction clean(test) {\r\n  return {\r\n      title: test.title\r\n    , fullTitle: test.fullTitle()\r\n    , duration: test.duration\r\n  }\r\n}\r\n\r\n}); // module: reporters/json-cov.js\r\n\r\nrequire.register(\"reporters/json-stream.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `List`.\r\n */\r\n\r\nexports = module.exports = List;\r\n\r\n/**\r\n * Initialize a new `List` test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction List(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , total = runner.total;\r\n\r\n  runner.on('start', function(){\r\n    console.log(JSON.stringify(['start', { total: total }]));\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    console.log(JSON.stringify(['pass', clean(test)]));\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    console.log(JSON.stringify(['fail', clean(test)]));\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    process.stdout.write(JSON.stringify(['end', self.stats]));\r\n  });\r\n}\r\n\r\n/**\r\n * Return a plain-object representation of `test`\r\n * free of cyclic properties etc.\r\n *\r\n * @param {Object} test\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction clean(test) {\r\n  return {\r\n      title: test.title\r\n    , fullTitle: test.fullTitle()\r\n    , duration: test.duration\r\n  }\r\n}\r\n}); // module: reporters/json-stream.js\r\n\r\nrequire.register(\"reporters/json.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `JSON`.\r\n */\r\n\r\nexports = module.exports = JSONReporter;\r\n\r\n/**\r\n * Initialize a new `JSON` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction JSONReporter(runner) {\r\n  var self = this;\r\n  Base.call(this, runner);\r\n\r\n  var tests = []\r\n    , failures = []\r\n    , passes = [];\r\n\r\n  runner.on('test end', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    passes.push(test);\r\n  });\r\n\r\n  runner.on('fail', function(test){\r\n    failures.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    var obj = {\r\n        stats: self.stats\r\n      , tests: tests.map(clean)\r\n      , failures: failures.map(clean)\r\n      , passes: passes.map(clean)\r\n    };\r\n\r\n    process.stdout.write(JSON.stringify(obj, null, 2));\r\n  });\r\n}\r\n\r\n/**\r\n * Return a plain-object representation of `test`\r\n * free of cyclic properties etc.\r\n *\r\n * @param {Object} test\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction clean(test) {\r\n  return {\r\n      title: test.title\r\n    , fullTitle: test.fullTitle()\r\n    , duration: test.duration\r\n  }\r\n}\r\n}); // module: reporters/json.js\r\n\r\nrequire.register(\"reporters/landing.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Landing`.\r\n */\r\n\r\nexports = module.exports = Landing;\r\n\r\n/**\r\n * Airplane color.\r\n */\r\n\r\nBase.colors.plane = 0;\r\n\r\n/**\r\n * Airplane crash color.\r\n */\r\n\r\nBase.colors['plane crash'] = 31;\r\n\r\n/**\r\n * Runway color.\r\n */\r\n\r\nBase.colors.runway = 90;\r\n\r\n/**\r\n * Initialize a new `Landing` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Landing(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , width = Base.window.width * .75 | 0\r\n    , total = runner.total\r\n    , stream = process.stdout\r\n    , plane = color('plane', '✈')\r\n    , crashed = -1\r\n    , n = 0;\r\n\r\n  function runway() {\r\n    var buf = Array(width).join('-');\r\n    return '  ' + color('runway', buf);\r\n  }\r\n\r\n  runner.on('start', function(){\r\n    stream.write('\\n  ');\r\n    cursor.hide();\r\n  });\r\n\r\n  runner.on('test end', function(test){\r\n    // check if the plane crashed\r\n    var col = -1 == crashed\r\n      ? width * ++n / total | 0\r\n      : crashed;\r\n\r\n    // show the crash\r\n    if ('failed' == test.state) {\r\n      plane = color('plane crash', '✈');\r\n      crashed = col;\r\n    }\r\n\r\n    // render landing strip\r\n    stream.write('\\u001b[4F\\n\\n');\r\n    stream.write(runway());\r\n    stream.write('\\n  ');\r\n    stream.write(color('runway', Array(col).join('⋅')));\r\n    stream.write(plane)\r\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\n'));\r\n    stream.write(runway());\r\n    stream.write('\\u001b[0m');\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    cursor.show();\r\n    console.log();\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nLanding.prototype = new F;\r\nLanding.prototype.constructor = Landing;\r\n\r\n}); // module: reporters/landing.js\r\n\r\nrequire.register(\"reporters/list.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `List`.\r\n */\r\n\r\nexports = module.exports = List;\r\n\r\n/**\r\n * Initialize a new `List` test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction List(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , n = 0;\r\n\r\n  runner.on('start', function(){\r\n    console.log();\r\n  });\r\n\r\n  runner.on('test', function(test){\r\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    var fmt = color('checkmark', '  -')\r\n      + color('pending', ' %s');\r\n    console.log(fmt, test.fullTitle());\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    var fmt = color('checkmark', '  '+Base.symbols.dot)\r\n      + color('pass', ' %s: ')\r\n      + color(test.speed, '%dms');\r\n    cursor.CR();\r\n    console.log(fmt, test.fullTitle(), test.duration);\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    cursor.CR();\r\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\r\n  });\r\n\r\n  runner.on('end', self.epilogue.bind(self));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nList.prototype = new F;\r\nList.prototype.constructor = List;\r\n\r\n\r\n}); // module: reporters/list.js\r\n\r\nrequire.register(\"reporters/markdown.js\", function(module, exports, require){\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils');\r\n\r\n/**\r\n * Expose `Markdown`.\r\n */\r\n\r\nexports = module.exports = Markdown;\r\n\r\n/**\r\n * Initialize a new `Markdown` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Markdown(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , level = 0\r\n    , buf = '';\r\n\r\n  function title(str) {\r\n    return Array(level).join('#') + ' ' + str;\r\n  }\r\n\r\n  function indent() {\r\n    return Array(level).join('  ');\r\n  }\r\n\r\n  function mapTOC(suite, obj) {\r\n    var ret = obj;\r\n    obj = obj[suite.title] = obj[suite.title] || { suite: suite };\r\n    suite.suites.forEach(function(suite){\r\n      mapTOC(suite, obj);\r\n    });\r\n    return ret;\r\n  }\r\n\r\n  function stringifyTOC(obj, level) {\r\n    ++level;\r\n    var buf = '';\r\n    var link;\r\n    for (var key in obj) {\r\n      if ('suite' == key) continue;\r\n      if (key) link = ' - [' + key + '](#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\r\n      if (key) buf += Array(level).join('  ') + link;\r\n      buf += stringifyTOC(obj[key], level);\r\n    }\r\n    --level;\r\n    return buf;\r\n  }\r\n\r\n  function generateTOC(suite) {\r\n    var obj = mapTOC(suite, {});\r\n    return stringifyTOC(obj, 0);\r\n  }\r\n\r\n  generateTOC(runner.suite);\r\n\r\n  runner.on('suite', function(suite){\r\n    ++level;\r\n    var slug = utils.slug(suite.fullTitle());\r\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\r\n    buf += title(suite.title) + '\\n';\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    --level;\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    var code = utils.clean(test.fn.toString());\r\n    buf += test.title + '.\\n';\r\n    buf += '\\n```js\\n';\r\n    buf += code + '\\n';\r\n    buf += '```\\n\\n';\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    process.stdout.write('# TOC\\n');\r\n    process.stdout.write(generateTOC(runner.suite));\r\n    process.stdout.write(buf);\r\n  });\r\n}\r\n}); // module: reporters/markdown.js\r\n\r\nrequire.register(\"reporters/min.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base');\r\n\r\n/**\r\n * Expose `Min`.\r\n */\r\n\r\nexports = module.exports = Min;\r\n\r\n/**\r\n * Initialize a new `Min` minimal test reporter (best used with --watch).\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Min(runner) {\r\n  Base.call(this, runner);\r\n\r\n  runner.on('start', function(){\r\n    // clear screen\r\n    process.stdout.write('\\u001b[2J');\r\n    // set cursor position\r\n    process.stdout.write('\\u001b[1;3H');\r\n  });\r\n\r\n  runner.on('end', this.epilogue.bind(this));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nMin.prototype = new F;\r\nMin.prototype.constructor = Min;\r\n\r\n\r\n}); // module: reporters/min.js\r\n\r\nrequire.register(\"reporters/nyan.js\", function(module, exports, require){\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Dot`.\r\n */\r\n\r\nexports = module.exports = NyanCat;\r\n\r\n/**\r\n * Initialize a new `Dot` matrix test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction NyanCat(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , width = Base.window.width * .75 | 0\r\n    , rainbowColors = this.rainbowColors = self.generateColors()\r\n    , colorIndex = this.colorIndex = 0\r\n    , numerOfLines = this.numberOfLines = 4\r\n    , trajectories = this.trajectories = [[], [], [], []]\r\n    , nyanCatWidth = this.nyanCatWidth = 11\r\n    , trajectoryWidthMax = this.trajectoryWidthMax = (width - nyanCatWidth)\r\n    , scoreboardWidth = this.scoreboardWidth = 5\r\n    , tick = this.tick = 0\r\n    , n = 0;\r\n\r\n  runner.on('start', function(){\r\n    Base.cursor.hide();\r\n    self.draw('start');\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    self.draw('pending');\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    self.draw('pass');\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    self.draw('fail');\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    Base.cursor.show();\r\n    for (var i = 0; i < self.numberOfLines; i++) write('\\n');\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Draw the nyan cat with runner `status`.\r\n *\r\n * @param {String} status\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.draw = function(status){\r\n  this.appendRainbow();\r\n  this.drawScoreboard();\r\n  this.drawRainbow();\r\n  this.drawNyanCat(status);\r\n  this.tick = !this.tick;\r\n};\r\n\r\n/**\r\n * Draw the \"scoreboard\" showing the number\r\n * of passes, failures and pending tests.\r\n *\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.drawScoreboard = function(){\r\n  var stats = this.stats;\r\n  var colors = Base.colors;\r\n\r\n  function draw(color, n) {\r\n    write(' ');\r\n    write('\\u001b[' + color + 'm' + n + '\\u001b[0m');\r\n    write('\\n');\r\n  }\r\n\r\n  draw(colors.green, stats.passes);\r\n  draw(colors.fail, stats.failures);\r\n  draw(colors.pending, stats.pending);\r\n  write('\\n');\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Append the rainbow.\r\n *\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.appendRainbow = function(){\r\n  var segment = this.tick ? '_' : '-';\r\n  var rainbowified = this.rainbowify(segment);\r\n\r\n  for (var index = 0; index < this.numberOfLines; index++) {\r\n    var trajectory = this.trajectories[index];\r\n    if (trajectory.length >= this.trajectoryWidthMax) trajectory.shift();\r\n    trajectory.push(rainbowified);\r\n  }\r\n};\r\n\r\n/**\r\n * Draw the rainbow.\r\n *\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.drawRainbow = function(){\r\n  var self = this;\r\n\r\n  this.trajectories.forEach(function(line, index) {\r\n    write('\\u001b[' + self.scoreboardWidth + 'C');\r\n    write(line.join(''));\r\n    write('\\n');\r\n  });\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Draw the nyan cat with `status`.\r\n *\r\n * @param {String} status\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.drawNyanCat = function(status) {\r\n  var self = this;\r\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\r\n  var color = '\\u001b[' + startWidth + 'C';\r\n  var padding = '';\r\n  \r\n  write(color);\r\n  write('_,------,');\r\n  write('\\n');\r\n  \r\n  write(color);\r\n  padding = self.tick ? '  ' : '   ';\r\n  write('_|' + padding + '/\\\\_/\\\\ ');\r\n  write('\\n');\r\n  \r\n  write(color);\r\n  padding = self.tick ? '_' : '__';\r\n  var tail = self.tick ? '~' : '^';\r\n  var face;\r\n  switch (status) {\r\n    case 'pass':\r\n      face = '( ^ .^)';\r\n      break;\r\n    case 'fail':\r\n      face = '( o .o)';\r\n      break;\r\n    default:\r\n      face = '( - .-)';\r\n  }\r\n  write(tail + '|' + padding + face + ' ');\r\n  write('\\n');\r\n  \r\n  write(color);\r\n  padding = self.tick ? ' ' : '  ';\r\n  write(padding + '\"\"  \"\" ');\r\n  write('\\n');\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Move cursor up `n`.\r\n *\r\n * @param {Number} n\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.cursorUp = function(n) {\r\n  write('\\u001b[' + n + 'A');\r\n};\r\n\r\n/**\r\n * Move cursor down `n`.\r\n *\r\n * @param {Number} n\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.cursorDown = function(n) {\r\n  write('\\u001b[' + n + 'B');\r\n};\r\n\r\n/**\r\n * Generate rainbow colors.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.generateColors = function(){\r\n  var colors = [];\r\n\r\n  for (var i = 0; i < (6 * 7); i++) {\r\n    var pi3 = Math.floor(Math.PI / 3);\r\n    var n = (i * (1.0 / 6));\r\n    var r = Math.floor(3 * Math.sin(n) + 3);\r\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\r\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\r\n    colors.push(36 * r + 6 * g + b + 16);\r\n  }\r\n\r\n  return colors;\r\n};\r\n\r\n/**\r\n * Apply rainbow to the given `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.rainbowify = function(str){\r\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\r\n  this.colorIndex += 1;\r\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\r\n};\r\n\r\n/**\r\n * Stdout helper.\r\n */\r\n\r\nfunction write(string) {\r\n  process.stdout.write(string);\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nNyanCat.prototype = new F;\r\nNyanCat.prototype.constructor = NyanCat;\r\n\r\n\r\n}); // module: reporters/nyan.js\r\n\r\nrequire.register(\"reporters/progress.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Progress`.\r\n */\r\n\r\nexports = module.exports = Progress;\r\n\r\n/**\r\n * General progress bar color.\r\n */\r\n\r\nBase.colors.progress = 90;\r\n\r\n/**\r\n * Initialize a new `Progress` bar test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @param {Object} options\r\n * @api public\r\n */\r\n\r\nfunction Progress(runner, options) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , options = options || {}\r\n    , stats = this.stats\r\n    , width = Base.window.width * .50 | 0\r\n    , total = runner.total\r\n    , complete = 0\r\n    , max = Math.max;\r\n\r\n  // default chars\r\n  options.open = options.open || '[';\r\n  options.complete = options.complete || '▬';\r\n  options.incomplete = options.incomplete || Base.symbols.dot;\r\n  options.close = options.close || ']';\r\n  options.verbose = false;\r\n\r\n  // tests started\r\n  runner.on('start', function(){\r\n    console.log();\r\n    cursor.hide();\r\n  });\r\n\r\n  // tests complete\r\n  runner.on('test end', function(){\r\n    complete++;\r\n    var incomplete = total - complete\r\n      , percent = complete / total\r\n      , n = width * percent | 0\r\n      , i = width - n;\r\n\r\n    cursor.CR();\r\n    process.stdout.write('\\u001b[J');\r\n    process.stdout.write(color('progress', '  ' + options.open));\r\n    process.stdout.write(Array(n).join(options.complete));\r\n    process.stdout.write(Array(i).join(options.incomplete));\r\n    process.stdout.write(color('progress', options.close));\r\n    if (options.verbose) {\r\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\r\n    }\r\n  });\r\n\r\n  // tests are complete, output some stats\r\n  // and the failures if any\r\n  runner.on('end', function(){\r\n    cursor.show();\r\n    console.log();\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nProgress.prototype = new F;\r\nProgress.prototype.constructor = Progress;\r\n\r\n\r\n}); // module: reporters/progress.js\r\n\r\nrequire.register(\"reporters/spec.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Spec`.\r\n */\r\n\r\nexports = module.exports = Spec;\r\n\r\n/**\r\n * Initialize a new `Spec` test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Spec(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , indents = 0\r\n    , n = 0;\r\n\r\n  function indent() {\r\n    return Array(indents).join('  ')\r\n  }\r\n\r\n  runner.on('start', function(){\r\n    console.log();\r\n  });\r\n\r\n  runner.on('suite', function(suite){\r\n    ++indents;\r\n    console.log(color('suite', '%s%s'), indent(), suite.title);\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    --indents;\r\n    if (1 == indents) console.log();\r\n  });\r\n\r\n  runner.on('test', function(test){\r\n    process.stdout.write(indent() + color('pass', '  ◦ ' + test.title + ': '));\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    var fmt = indent() + color('pending', '  - %s');\r\n    console.log(fmt, test.title);\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    if ('fast' == test.speed) {\r\n      var fmt = indent()\r\n        + color('checkmark', '  ' + Base.symbols.ok)\r\n        + color('pass', ' %s ');\r\n      cursor.CR();\r\n      console.log(fmt, test.title);\r\n    } else {\r\n      var fmt = indent()\r\n        + color('checkmark', '  ' + Base.symbols.ok)\r\n        + color('pass', ' %s ')\r\n        + color(test.speed, '(%dms)');\r\n      cursor.CR();\r\n      console.log(fmt, test.title, test.duration);\r\n    }\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    cursor.CR();\r\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\r\n  });\r\n\r\n  runner.on('end', self.epilogue.bind(self));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nSpec.prototype = new F;\r\nSpec.prototype.constructor = Spec;\r\n\r\n\r\n}); // module: reporters/spec.js\r\n\r\nrequire.register(\"reporters/tap.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `TAP`.\r\n */\r\n\r\nexports = module.exports = TAP;\r\n\r\n/**\r\n * Initialize a new `TAP` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction TAP(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , n = 1\r\n    , passes = 0\r\n    , failures = 0;\r\n\r\n  runner.on('start', function(){\r\n    var total = runner.grepTotal(runner.suite);\r\n    console.log('%d..%d', 1, total);\r\n  });\r\n\r\n  runner.on('test end', function(){\r\n    ++n;\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    console.log('ok %d %s # SKIP -', n, title(test));\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    passes++;\r\n    console.log('ok %d %s', n, title(test));\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    failures++;\r\n    console.log('not ok %d %s', n, title(test));\r\n    if (err.stack) console.log(err.stack.replace(/^/gm, '  '));\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    console.log('# tests ' + (passes + failures));\r\n    console.log('# pass ' + passes);\r\n    console.log('# fail ' + failures);\r\n  });\r\n}\r\n\r\n/**\r\n * Return a TAP-safe title of `test`\r\n *\r\n * @param {Object} test\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction title(test) {\r\n  return test.fullTitle().replace(/#/g, '');\r\n}\r\n\r\n}); // module: reporters/tap.js\r\n\r\nrequire.register(\"reporters/teamcity.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base');\r\n\r\n/**\r\n * Expose `Teamcity`.\r\n */\r\n\r\nexports = module.exports = Teamcity;\r\n\r\n/**\r\n * Initialize a new `Teamcity` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Teamcity(runner) {\r\n  Base.call(this, runner);\r\n  var stats = this.stats;\r\n\r\n  runner.on('start', function() {\r\n    console.log(\"##teamcity[testSuiteStarted name='mocha.suite']\");\r\n  });\r\n\r\n  runner.on('test', function(test) {\r\n    console.log(\"##teamcity[testStarted name='\" + escape(test.fullTitle()) + \"']\");\r\n  });\r\n\r\n  runner.on('fail', function(test, err) {\r\n    console.log(\"##teamcity[testFailed name='\" + escape(test.fullTitle()) + \"' message='\" + escape(err.message) + \"']\");\r\n  });\r\n\r\n  runner.on('pending', function(test) {\r\n    console.log(\"##teamcity[testIgnored name='\" + escape(test.fullTitle()) + \"' message='pending']\");\r\n  });\r\n\r\n  runner.on('test end', function(test) {\r\n    console.log(\"##teamcity[testFinished name='\" + escape(test.fullTitle()) + \"' duration='\" + test.duration + \"']\");\r\n  });\r\n\r\n  runner.on('end', function() {\r\n    console.log(\"##teamcity[testSuiteFinished name='mocha.suite' duration='\" + stats.duration + \"']\");\r\n  });\r\n}\r\n\r\n/**\r\n * Escape the given `str`.\r\n */\r\n\r\nfunction escape(str) {\r\n  return str\r\n    .replace(/\\|/g, \"||\")\r\n    .replace(/\\n/g, \"|n\")\r\n    .replace(/\\r/g, \"|r\")\r\n    .replace(/\\[/g, \"|[\")\r\n    .replace(/\\]/g, \"|]\")\r\n    .replace(/\\u0085/g, \"|x\")\r\n    .replace(/\\u2028/g, \"|l\")\r\n    .replace(/\\u2029/g, \"|p\")\r\n    .replace(/'/g, \"|'\");\r\n}\r\n\r\n}); // module: reporters/teamcity.js\r\n\r\nrequire.register(\"reporters/xunit.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils')\r\n  , escape = utils.escape;\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Expose `XUnit`.\r\n */\r\n\r\nexports = module.exports = XUnit;\r\n\r\n/**\r\n * Initialize a new `XUnit` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction XUnit(runner) {\r\n  Base.call(this, runner);\r\n  var stats = this.stats\r\n    , tests = []\r\n    , self = this;\r\n\r\n  runner.on('pass', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('fail', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    console.log(tag('testsuite', {\r\n        name: 'Mocha Tests'\r\n      , tests: stats.tests\r\n      , failures: stats.failures\r\n      , errors: stats.failures\r\n      , skip: stats.tests - stats.failures - stats.passes\r\n      , timestamp: (new Date).toUTCString()\r\n      , time: stats.duration / 1000\r\n    }, false));\r\n\r\n    tests.forEach(test);\r\n    console.log('</testsuite>');\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nXUnit.prototype = new F;\r\nXUnit.prototype.constructor = XUnit;\r\n\r\n\r\n/**\r\n * Output tag for the given `test.`\r\n */\r\n\r\nfunction test(test) {\r\n  var attrs = {\r\n      classname: test.parent.fullTitle()\r\n    , name: test.title\r\n    , time: test.duration / 1000\r\n  };\r\n\r\n  if ('failed' == test.state) {\r\n    var err = test.err;\r\n    attrs.message = escape(err.message);\r\n    console.log(tag('testcase', attrs, false, tag('failure', attrs, false, cdata(err.stack))));\r\n  } else if (test.pending) {\r\n    console.log(tag('testcase', attrs, false, tag('skipped', {}, true)));\r\n  } else {\r\n    console.log(tag('testcase', attrs, true) );\r\n  }\r\n}\r\n\r\n/**\r\n * HTML tag helper.\r\n */\r\n\r\nfunction tag(name, attrs, close, content) {\r\n  var end = close ? '/>' : '>'\r\n    , pairs = []\r\n    , tag;\r\n\r\n  for (var key in attrs) {\r\n    pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\r\n  }\r\n\r\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\r\n  if (content) tag += content + '</' + name + end;\r\n  return tag;\r\n}\r\n\r\n/**\r\n * Return cdata escaped CDATA `str`.\r\n */\r\n\r\nfunction cdata(str) {\r\n  return '<![CDATA[' + escape(str) + ']]>';\r\n}\r\n\r\n}); // module: reporters/xunit.js\r\n\r\nrequire.register(\"runnable.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar EventEmitter = require('browser/events').EventEmitter\r\n  , debug = require('browser/debug')('mocha:runnable')\r\n  , milliseconds = require('./ms');\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Object#toString().\r\n */\r\n\r\nvar toString = Object.prototype.toString;\r\n\r\n/**\r\n * Expose `Runnable`.\r\n */\r\n\r\nmodule.exports = Runnable;\r\n\r\n/**\r\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\r\n *\r\n * @param {String} title\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nfunction Runnable(title, fn) {\r\n  this.title = title;\r\n  this.fn = fn;\r\n  this.async = fn && fn.length;\r\n  this.sync = ! this.async;\r\n  this._timeout = 2000;\r\n  this._slow = 75;\r\n  this.timedOut = false;\r\n}\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = EventEmitter.prototype;\r\nRunnable.prototype = new F;\r\nRunnable.prototype.constructor = Runnable;\r\n\r\n\r\n/**\r\n * Set & get timeout `ms`.\r\n *\r\n * @param {Number|String} ms\r\n * @return {Runnable|Number} ms or self\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.timeout = function(ms){\r\n  if (0 == arguments.length) return this._timeout;\r\n  if ('string' == typeof ms) ms = milliseconds(ms);\r\n  debug('timeout %d', ms);\r\n  this._timeout = ms;\r\n  if (this.timer) this.resetTimeout();\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set & get slow `ms`.\r\n *\r\n * @param {Number|String} ms\r\n * @return {Runnable|Number} ms or self\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.slow = function(ms){\r\n  if (0 === arguments.length) return this._slow;\r\n  if ('string' == typeof ms) ms = milliseconds(ms);\r\n  debug('timeout %d', ms);\r\n  this._slow = ms;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return the full title generated by recursively\r\n * concatenating the parent's full title.\r\n *\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nRunnable.prototype.fullTitle = function(){\r\n  return this.parent.fullTitle() + ' ' + this.title;\r\n};\r\n\r\n/**\r\n * Clear the timeout.\r\n *\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.clearTimeout = function(){\r\n  clearTimeout(this.timer);\r\n};\r\n\r\n/**\r\n * Inspect the runnable void of private properties.\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.inspect = function(){\r\n  return JSON.stringify(this, function(key, val){\r\n    if ('_' == key[0]) return;\r\n    if ('parent' == key) return '#<Suite>';\r\n    if ('ctx' == key) return '#<Context>';\r\n    return val;\r\n  }, 2);\r\n};\r\n\r\n/**\r\n * Reset the timeout.\r\n *\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.resetTimeout = function(){\r\n  var self = this\r\n    , ms = this.timeout();\r\n\r\n  this.clearTimeout();\r\n  if (ms) {\r\n    this.timer = setTimeout(function(){\r\n      self.callback(new Error('timeout of ' + ms + 'ms exceeded'));\r\n      self.timedOut = true;\r\n    }, ms);\r\n  }\r\n};\r\n\r\n/**\r\n * Run the test and invoke `fn(err)`.\r\n *\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.run = function(fn){\r\n  var self = this\r\n    , ms = this.timeout()\r\n    , start = new Date\r\n    , ctx = this.ctx\r\n    , finished\r\n    , emitted;\r\n\r\n  if (ctx) ctx.runnable(this);\r\n\r\n  // timeout\r\n  if (this.async) {\r\n    if (ms) {\r\n      this.timer = setTimeout(function(){\r\n        done(new Error('timeout of ' + ms + 'ms exceeded'));\r\n        self.timedOut = true;\r\n      }, ms);\r\n    }\r\n  }\r\n\r\n  // called multiple times\r\n  function multiple(err) {\r\n    if (emitted) return;\r\n    emitted = true;\r\n    self.emit('error', err || new Error('done() called multiple times'));\r\n  }\r\n\r\n  // finished\r\n  function done(err) {\r\n    if (self.timedOut) return;\r\n    if (finished) return multiple(err);\r\n    self.clearTimeout();\r\n    self.duration = new Date - start;\r\n    finished = true;\r\n    fn(err);\r\n  }\r\n\r\n  // for .resetTimeout()\r\n  this.callback = done;\r\n\r\n  // async\r\n  if (this.async) {\r\n    try {\r\n      this.fn.call(ctx, function(err){\r\n        if (err instanceof Error || toString.call(err) === \"[object Error]\") return done(err);\r\n        if (null != err) return done(new Error('done() invoked with non-Error: ' + err));\r\n        done();\r\n      });\r\n    } catch (err) {\r\n      done(err);\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (this.asyncOnly) {\r\n    return done(new Error('--async-only option in use without declaring `done()`'));\r\n  }\r\n\r\n  // sync\r\n  try {\r\n    if (!this.pending) this.fn.call(ctx);\r\n    this.duration = new Date - start;\r\n    fn();\r\n  } catch (err) {\r\n    fn(err);\r\n  }\r\n};\r\n\r\n}); // module: runnable.js\r\n\r\nrequire.register(\"runner.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar EventEmitter = require('browser/events').EventEmitter\r\n  , debug = require('browser/debug')('mocha:runner')\r\n  , Test = require('./test')\r\n  , utils = require('./utils')\r\n  , filter = utils.filter\r\n  , keys = utils.keys;\r\n\r\n/**\r\n * Non-enumerable globals.\r\n */\r\n\r\nvar globals = [\r\n  'setTimeout',\r\n  'clearTimeout',\r\n  'setInterval',\r\n  'clearInterval',\r\n  'XMLHttpRequest',\r\n  'Date'\r\n];\r\n\r\n/**\r\n * Expose `Runner`.\r\n */\r\n\r\nmodule.exports = Runner;\r\n\r\n/**\r\n * Initialize a `Runner` for the given `suite`.\r\n *\r\n * Events:\r\n *\r\n *   - `start`  execution started\r\n *   - `end`  execution complete\r\n *   - `suite`  (suite) test suite execution started\r\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\r\n *   - `test`  (test) test execution started\r\n *   - `test end`  (test) test completed\r\n *   - `hook`  (hook) hook execution started\r\n *   - `hook end`  (hook) hook complete\r\n *   - `pass`  (test) test passed\r\n *   - `fail`  (test, err) test failed\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Runner(suite) {\r\n  var self = this;\r\n  this._globals = [];\r\n  this.suite = suite;\r\n  this.total = suite.total();\r\n  this.failures = 0;\r\n  this.on('test end', function(test){ self.checkGlobals(test); });\r\n  this.on('hook end', function(hook){ self.checkGlobals(hook); });\r\n  this.grep(/.*/);\r\n  this.globals(this.globalProps().concat(['errno']));\r\n}\r\n\r\n/**\r\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\r\n *\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.immediately = global.setImmediate || process.nextTick;\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = EventEmitter.prototype;\r\nRunner.prototype = new F;\r\nRunner.prototype.constructor = Runner;\r\n\r\n\r\n/**\r\n * Run tests with full titles matching `re`. Updates runner.total\r\n * with number of tests matched.\r\n *\r\n * @param {RegExp} re\r\n * @param {Boolean} invert\r\n * @return {Runner} for chaining\r\n * @api public\r\n */\r\n\r\nRunner.prototype.grep = function(re, invert){\r\n  debug('grep %s', re);\r\n  this._grep = re;\r\n  this._invert = invert;\r\n  this.total = this.grepTotal(this.suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns the number of tests matching the grep search for the\r\n * given suite.\r\n *\r\n * @param {Suite} suite\r\n * @return {Number}\r\n * @api public\r\n */\r\n\r\nRunner.prototype.grepTotal = function(suite) {\r\n  var self = this;\r\n  var total = 0;\r\n\r\n  suite.eachTest(function(test){\r\n    var match = self._grep.test(test.fullTitle());\r\n    if (self._invert) match = !match;\r\n    if (match) total++;\r\n  });\r\n\r\n  return total;\r\n};\r\n\r\n/**\r\n * Return a list of global properties.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nRunner.prototype.globalProps = function() {\r\n  var props = utils.keys(global);\r\n\r\n  // non-enumerables\r\n  for (var i = 0; i < globals.length; ++i) {\r\n    if (~utils.indexOf(props, globals[i])) continue;\r\n    props.push(globals[i]);\r\n  }\r\n\r\n  return props;\r\n};\r\n\r\n/**\r\n * Allow the given `arr` of globals.\r\n *\r\n * @param {Array} arr\r\n * @return {Runner} for chaining\r\n * @api public\r\n */\r\n\r\nRunner.prototype.globals = function(arr){\r\n  if (0 == arguments.length) return this._globals;\r\n  debug('globals %j', arr);\r\n  utils.forEach(arr, function(arr){\r\n    this._globals.push(arr);\r\n  }, this);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Check for global variable leaks.\r\n *\r\n * @api private\r\n */\r\n\r\nRunner.prototype.checkGlobals = function(test){\r\n  if (this.ignoreLeaks) return;\r\n  var ok = this._globals;\r\n  var globals = this.globalProps();\r\n  var isNode = process.kill;\r\n  var leaks;\r\n\r\n  // check length - 2 ('errno' and 'location' globals)\r\n  if (isNode && 1 == ok.length - globals.length) return\r\n  else if (2 == ok.length - globals.length) return;\r\n\r\n  leaks = filterLeaks(ok, globals);\r\n  this._globals = this._globals.concat(leaks);\r\n\r\n  if (leaks.length > 1) {\r\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\r\n  } else if (leaks.length) {\r\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\r\n  }\r\n};\r\n\r\n/**\r\n * Fail the given `test`.\r\n *\r\n * @param {Test} test\r\n * @param {Error} err\r\n * @api private\r\n */\r\n\r\nRunner.prototype.fail = function(test, err){\r\n  ++this.failures;\r\n  test.state = 'failed';\r\n\r\n  if ('string' == typeof err) {\r\n    err = new Error('the string \"' + err + '\" was thrown, throw an Error :)');\r\n  }\r\n\r\n  this.emit('fail', test, err);\r\n};\r\n\r\n/**\r\n * Fail the given `hook` with `err`.\r\n *\r\n * Hook failures (currently) hard-end due\r\n * to that fact that a failing hook will\r\n * surely cause subsequent tests to fail,\r\n * causing jumbled reporting.\r\n *\r\n * @param {Hook} hook\r\n * @param {Error} err\r\n * @api private\r\n */\r\n\r\nRunner.prototype.failHook = function(hook, err){\r\n  this.fail(hook, err);\r\n  this.emit('end');\r\n};\r\n\r\n/**\r\n * Run hook `name` callbacks and then invoke `fn()`.\r\n *\r\n * @param {String} name\r\n * @param {Function} function\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hook = function(name, fn){\r\n  var suite = this.suite\r\n    , hooks = suite['_' + name]\r\n    , self = this\r\n    , timer;\r\n\r\n  function next(i) {\r\n    var hook = hooks[i];\r\n    if (!hook) return fn();\r\n    self.currentRunnable = hook;\r\n\r\n    self.emit('hook', hook);\r\n\r\n    hook.on('error', function(err){\r\n      self.failHook(hook, err);\r\n    });\r\n\r\n    hook.run(function(err){\r\n      hook.removeAllListeners('error');\r\n      var testError = hook.error();\r\n      if (testError) self.fail(self.test, testError);\r\n      if (err) return self.failHook(hook, err);\r\n      self.emit('hook end', hook);\r\n      next(++i);\r\n    });\r\n  }\r\n\r\n  Runner.immediately(function(){\r\n    next(0);\r\n  });\r\n};\r\n\r\n/**\r\n * Run hook `name` for the given array of `suites`\r\n * in order, and callback `fn(err)`.\r\n *\r\n * @param {String} name\r\n * @param {Array} suites\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hooks = function(name, suites, fn){\r\n  var self = this\r\n    , orig = this.suite;\r\n\r\n  function next(suite) {\r\n    self.suite = suite;\r\n\r\n    if (!suite) {\r\n      self.suite = orig;\r\n      return fn();\r\n    }\r\n\r\n    self.hook(name, function(err){\r\n      if (err) {\r\n        self.suite = orig;\r\n        return fn(err);\r\n      }\r\n\r\n      next(suites.pop());\r\n    });\r\n  }\r\n\r\n  next(suites.pop());\r\n};\r\n\r\n/**\r\n * Run hooks from the top level down.\r\n *\r\n * @param {String} name\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hookUp = function(name, fn){\r\n  var suites = [this.suite].concat(this.parents()).reverse();\r\n  this.hooks(name, suites, fn);\r\n};\r\n\r\n/**\r\n * Run hooks from the bottom up.\r\n *\r\n * @param {String} name\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hookDown = function(name, fn){\r\n  var suites = [this.suite].concat(this.parents());\r\n  this.hooks(name, suites, fn);\r\n};\r\n\r\n/**\r\n * Return an array of parent Suites from\r\n * closest to furthest.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nRunner.prototype.parents = function(){\r\n  var suite = this.suite\r\n    , suites = [];\r\n  while (suite = suite.parent) suites.push(suite);\r\n  return suites;\r\n};\r\n\r\n/**\r\n * Run the current test and callback `fn(err)`.\r\n *\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.runTest = function(fn){\r\n  var test = this.test\r\n    , self = this;\r\n\r\n  if (this.asyncOnly) test.asyncOnly = true;\r\n\r\n  try {\r\n    test.on('error', function(err){\r\n      self.fail(test, err);\r\n    });\r\n    test.run(fn);\r\n  } catch (err) {\r\n    fn(err);\r\n  }\r\n};\r\n\r\n/**\r\n * Run tests in the given `suite` and invoke\r\n * the callback `fn()` when complete.\r\n *\r\n * @param {Suite} suite\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.runTests = function(suite, fn){\r\n  var self = this\r\n    , tests = suite.tests.slice()\r\n    , test;\r\n\r\n  function next(err) {\r\n    // if we bail after first err\r\n    if (self.failures && suite._bail) return fn();\r\n\r\n    // next test\r\n    test = tests.shift();\r\n\r\n    // all done\r\n    if (!test) return fn();\r\n\r\n    // grep\r\n    var match = self._grep.test(test.fullTitle());\r\n    if (self._invert) match = !match;\r\n    if (!match) return next();\r\n\r\n    // pending\r\n    if (test.pending) {\r\n      self.emit('pending', test);\r\n      self.emit('test end', test);\r\n      return next();\r\n    }\r\n\r\n    // execute test and hook(s)\r\n    self.emit('test', self.test = test);\r\n    self.hookDown('beforeEach', function(){\r\n      self.currentRunnable = self.test;\r\n      self.runTest(function(err){\r\n        test = self.test;\r\n\r\n        if (err) {\r\n          self.fail(test, err);\r\n          self.emit('test end', test);\r\n          return self.hookUp('afterEach', next);\r\n        }\r\n\r\n        test.state = 'passed';\r\n        self.emit('pass', test);\r\n        self.emit('test end', test);\r\n        self.hookUp('afterEach', next);\r\n      });\r\n    });\r\n  }\r\n\r\n  this.next = next;\r\n  next();\r\n};\r\n\r\n/**\r\n * Run the given `suite` and invoke the\r\n * callback `fn()` when complete.\r\n *\r\n * @param {Suite} suite\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.runSuite = function(suite, fn){\r\n  var total = this.grepTotal(suite)\r\n    , self = this\r\n    , i = 0;\r\n\r\n  debug('run suite %s', suite.fullTitle());\r\n\r\n  if (!total) return fn();\r\n\r\n  this.emit('suite', this.suite = suite);\r\n\r\n  function next() {\r\n    var curr = suite.suites[i++];\r\n    if (!curr) return done();\r\n    self.runSuite(curr, next);\r\n  }\r\n\r\n  function done() {\r\n    self.suite = suite;\r\n    self.hook('afterAll', function(){\r\n      self.emit('suite end', suite);\r\n      fn();\r\n    });\r\n  }\r\n\r\n  this.hook('beforeAll', function(){\r\n    self.runTests(suite, next);\r\n  });\r\n};\r\n\r\n/**\r\n * Handle uncaught exceptions.\r\n *\r\n * @param {Error} err\r\n * @api private\r\n */\r\n\r\nRunner.prototype.uncaught = function(err){\r\n  debug('uncaught exception %s', err.message);\r\n  var runnable = this.currentRunnable;\r\n  if (!runnable || 'failed' == runnable.state) return;\r\n  runnable.clearTimeout();\r\n  err.uncaught = true;\r\n  this.fail(runnable, err);\r\n\r\n  // recover from test\r\n  if ('test' == runnable.type) {\r\n    this.emit('test end', runnable);\r\n    this.hookUp('afterEach', this.next);\r\n    return;\r\n  }\r\n\r\n  // bail on hooks\r\n  this.emit('end');\r\n};\r\n\r\n/**\r\n * Run the root suite and invoke `fn(failures)`\r\n * on completion.\r\n *\r\n * @param {Function} fn\r\n * @return {Runner} for chaining\r\n * @api public\r\n */\r\n\r\nRunner.prototype.run = function(fn){\r\n  var self = this\r\n    , fn = fn || function(){};\r\n\r\n  function uncaught(err){\r\n    self.uncaught(err);\r\n  }\r\n\r\n  debug('start');\r\n\r\n  // callback\r\n  this.on('end', function(){\r\n    debug('end');\r\n    process.removeListener('uncaughtException', uncaught);\r\n    fn(self.failures);\r\n  });\r\n\r\n  // run suites\r\n  this.emit('start');\r\n  this.runSuite(this.suite, function(){\r\n    debug('finished running');\r\n    self.emit('end');\r\n  });\r\n\r\n  // uncaught exception\r\n  process.on('uncaughtException', uncaught);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Filter leaks with the given globals flagged as `ok`.\r\n *\r\n * @param {Array} ok\r\n * @param {Array} globals\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nfunction filterLeaks(ok, globals) {\r\n  return filter(globals, function(key){\r\n    var matched = filter(ok, function(ok){\r\n      if (~ok.indexOf('*')) return 0 == key.indexOf(ok.split('*')[0]);\r\n      // Opera and IE expose global variables for HTML element IDs (issue #243)\r\n      if (/^mocha-/.test(key)) return true;\r\n      return key == ok;\r\n    });\r\n    return matched.length == 0 && (!global.navigator || 'onerror' !== key);\r\n  });\r\n}\r\n\r\n}); // module: runner.js\r\n\r\nrequire.register(\"suite.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar EventEmitter = require('browser/events').EventEmitter\r\n  , debug = require('browser/debug')('mocha:suite')\r\n  , milliseconds = require('./ms')\r\n  , utils = require('./utils')\r\n  , Hook = require('./hook');\r\n\r\n/**\r\n * Expose `Suite`.\r\n */\r\n\r\nexports = module.exports = Suite;\r\n\r\n/**\r\n * Create a new `Suite` with the given `title`\r\n * and parent `Suite`. When a suite with the\r\n * same title is already present, that suite\r\n * is returned to provide nicer reporter\r\n * and more flexible meta-testing.\r\n *\r\n * @param {Suite} parent\r\n * @param {String} title\r\n * @return {Suite}\r\n * @api public\r\n */\r\n\r\nexports.create = function(parent, title){\r\n  var suite = new Suite(title, parent.ctx);\r\n  suite.parent = parent;\r\n  if (parent.pending) suite.pending = true;\r\n  title = suite.fullTitle();\r\n  parent.addSuite(suite);\r\n  return suite;\r\n};\r\n\r\n/**\r\n * Initialize a new `Suite` with the given\r\n * `title` and `ctx`.\r\n *\r\n * @param {String} title\r\n * @param {Context} ctx\r\n * @api private\r\n */\r\n\r\nfunction Suite(title, ctx) {\r\n  this.title = title;\r\n  this.ctx = ctx;\r\n  this.suites = [];\r\n  this.tests = [];\r\n  this.pending = false;\r\n  this._beforeEach = [];\r\n  this._beforeAll = [];\r\n  this._afterEach = [];\r\n  this._afterAll = [];\r\n  this.root = !title;\r\n  this._timeout = 2000;\r\n  this._slow = 75;\r\n  this._bail = false;\r\n}\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = EventEmitter.prototype;\r\nSuite.prototype = new F;\r\nSuite.prototype.constructor = Suite;\r\n\r\n\r\n/**\r\n * Return a clone of this `Suite`.\r\n *\r\n * @return {Suite}\r\n * @api private\r\n */\r\n\r\nSuite.prototype.clone = function(){\r\n  var suite = new Suite(this.title);\r\n  debug('clone');\r\n  suite.ctx = this.ctx;\r\n  suite.timeout(this.timeout());\r\n  suite.slow(this.slow());\r\n  suite.bail(this.bail());\r\n  return suite;\r\n};\r\n\r\n/**\r\n * Set timeout `ms` or short-hand such as \"2s\".\r\n *\r\n * @param {Number|String} ms\r\n * @return {Suite|Number} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.timeout = function(ms){\r\n  if (0 == arguments.length) return this._timeout;\r\n  if ('string' == typeof ms) ms = milliseconds(ms);\r\n  debug('timeout %d', ms);\r\n  this._timeout = parseInt(ms, 10);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set slow `ms` or short-hand such as \"2s\".\r\n *\r\n * @param {Number|String} ms\r\n * @return {Suite|Number} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.slow = function(ms){\r\n  if (0 === arguments.length) return this._slow;\r\n  if ('string' == typeof ms) ms = milliseconds(ms);\r\n  debug('slow %d', ms);\r\n  this._slow = ms;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets whether to bail after first error.\r\n *\r\n * @parma {Boolean} bail\r\n * @return {Suite|Number} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.bail = function(bail){\r\n  if (0 == arguments.length) return this._bail;\r\n  debug('bail %s', bail);\r\n  this._bail = bail;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` before running tests.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.beforeAll = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"before all\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._beforeAll.push(hook);\r\n  this.emit('beforeAll', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` after running tests.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.afterAll = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"after all\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._afterAll.push(hook);\r\n  this.emit('afterAll', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` before each test case.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.beforeEach = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"before each\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._beforeEach.push(hook);\r\n  this.emit('beforeEach', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` after each test case.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.afterEach = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"after each\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._afterEach.push(hook);\r\n  this.emit('afterEach', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a test `suite`.\r\n *\r\n * @param {Suite} suite\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.addSuite = function(suite){\r\n  suite.parent = this;\r\n  suite.timeout(this.timeout());\r\n  suite.slow(this.slow());\r\n  suite.bail(this.bail());\r\n  this.suites.push(suite);\r\n  this.emit('suite', suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a `test` to this suite.\r\n *\r\n * @param {Test} test\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.addTest = function(test){\r\n  test.parent = this;\r\n  test.timeout(this.timeout());\r\n  test.slow(this.slow());\r\n  test.ctx = this.ctx;\r\n  this.tests.push(test);\r\n  this.emit('test', test);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return the full title generated by recursively\r\n * concatenating the parent's full title.\r\n *\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nSuite.prototype.fullTitle = function(){\r\n  if (this.parent) {\r\n    var full = this.parent.fullTitle();\r\n    if (full) return full + ' ' + this.title;\r\n  }\r\n  return this.title;\r\n};\r\n\r\n/**\r\n * Return the total number of tests.\r\n *\r\n * @return {Number}\r\n * @api public\r\n */\r\n\r\nSuite.prototype.total = function(){\r\n  return utils.reduce(this.suites, function(sum, suite){\r\n    return sum + suite.total();\r\n  }, 0) + this.tests.length;\r\n};\r\n\r\n/**\r\n * Iterates through each suite recursively to find\r\n * all tests. Applies a function in the format\r\n * `fn(test)`.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite}\r\n * @api private\r\n */\r\n\r\nSuite.prototype.eachTest = function(fn){\r\n  utils.forEach(this.tests, fn);\r\n  utils.forEach(this.suites, function(suite){\r\n    suite.eachTest(fn);\r\n  });\r\n  return this;\r\n};\r\n\r\n}); // module: suite.js\r\n\r\nrequire.register(\"test.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Runnable = require('./runnable');\r\n\r\n/**\r\n * Expose `Test`.\r\n */\r\n\r\nmodule.exports = Test;\r\n\r\n/**\r\n * Initialize a new `Test` with the given `title` and callback `fn`.\r\n *\r\n * @param {String} title\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nfunction Test(title, fn) {\r\n  Runnable.call(this, title, fn);\r\n  this.pending = !fn;\r\n  this.type = 'test';\r\n}\r\n\r\n/**\r\n * Inherit from `Runnable.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Runnable.prototype;\r\nTest.prototype = new F;\r\nTest.prototype.constructor = Test;\r\n\r\n\r\n}); // module: test.js\r\n\r\nrequire.register(\"utils.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar fs = require('browser/fs')\r\n  , path = require('browser/path')\r\n  , join = path.join\r\n  , debug = require('browser/debug')('mocha:watch');\r\n\r\n/**\r\n * Ignored directories.\r\n */\r\n\r\nvar ignore = ['node_modules', '.git'];\r\n\r\n/**\r\n * Escape special characters in the given string of html.\r\n *\r\n * @param  {String} html\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.escape = function(html){\r\n  return String(html)\r\n    .replace(/&/g, '&amp;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;');\r\n};\r\n\r\n/**\r\n * Array#forEach (<=IE8)\r\n *\r\n * @param {Array} array\r\n * @param {Function} fn\r\n * @param {Object} scope\r\n * @api private\r\n */\r\n\r\nexports.forEach = function(arr, fn, scope){\r\n  for (var i = 0, l = arr.length; i < l; i++)\r\n    fn.call(scope, arr[i], i);\r\n};\r\n\r\n/**\r\n * Array#indexOf (<=IE8)\r\n *\r\n * @parma {Array} arr\r\n * @param {Object} obj to find index of\r\n * @param {Number} start\r\n * @api private\r\n */\r\n\r\nexports.indexOf = function(arr, obj, start){\r\n  for (var i = start || 0, l = arr.length; i < l; i++) {\r\n    if (arr[i] === obj)\r\n      return i;\r\n  }\r\n  return -1;\r\n};\r\n\r\n/**\r\n * Array#reduce (<=IE8)\r\n *\r\n * @param {Array} array\r\n * @param {Function} fn\r\n * @param {Object} initial value\r\n * @api private\r\n */\r\n\r\nexports.reduce = function(arr, fn, val){\r\n  var rval = val;\r\n\r\n  for (var i = 0, l = arr.length; i < l; i++) {\r\n    rval = fn(rval, arr[i], i, arr);\r\n  }\r\n\r\n  return rval;\r\n};\r\n\r\n/**\r\n * Array#filter (<=IE8)\r\n *\r\n * @param {Array} array\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nexports.filter = function(arr, fn){\r\n  var ret = [];\r\n\r\n  for (var i = 0, l = arr.length; i < l; i++) {\r\n    var val = arr[i];\r\n    if (fn(val, i, arr)) ret.push(val);\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Object.keys (<=IE8)\r\n *\r\n * @param {Object} obj\r\n * @return {Array} keys\r\n * @api private\r\n */\r\n\r\nexports.keys = Object.keys || function(obj) {\r\n  var keys = []\r\n    , has = Object.prototype.hasOwnProperty // for `window` on <=IE8\r\n\r\n  for (var key in obj) {\r\n    if (has.call(obj, key)) {\r\n      keys.push(key);\r\n    }\r\n  }\r\n\r\n  return keys;\r\n};\r\n\r\n/**\r\n * Watch the given `files` for changes\r\n * and invoke `fn(file)` on modification.\r\n *\r\n * @param {Array} files\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nexports.watch = function(files, fn){\r\n  var options = { interval: 100 };\r\n  files.forEach(function(file){\r\n    debug('file %s', file);\r\n    fs.watchFile(file, options, function(curr, prev){\r\n      if (prev.mtime < curr.mtime) fn(file);\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Ignored files.\r\n */\r\n\r\nfunction ignored(path){\r\n  return !~ignore.indexOf(path);\r\n}\r\n\r\n/**\r\n * Lookup files in the given `dir`.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nexports.files = function(dir, ret){\r\n  ret = ret || [];\r\n\r\n  fs.readdirSync(dir)\r\n  .filter(ignored)\r\n  .forEach(function(path){\r\n    path = join(dir, path);\r\n    if (fs.statSync(path).isDirectory()) {\r\n      exports.files(path, ret);\r\n    } else if (path.match(/\\.(js|coffee)$/)) {\r\n      ret.push(path);\r\n    }\r\n  });\r\n\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Compute a slug from the given `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.slug = function(str){\r\n  return str\r\n    .toLowerCase()\r\n    .replace(/ +/g, '-')\r\n    .replace(/[^-\\w]/g, '');\r\n};\r\n\r\n/**\r\n * Strip the function definition from `str`,\r\n * and re-indent for pre whitespace.\r\n */\r\n\r\nexports.clean = function(str) {\r\n  str = str\r\n    .replace(/^function *\\(.*\\) *{/, '')\r\n    .replace(/\\s+\\}$/, '');\r\n\r\n  var spaces = str.match(/^\\n?( *)/)[1].length\r\n    , re = new RegExp('^ {' + spaces + '}', 'gm');\r\n\r\n  str = str.replace(re, '');\r\n\r\n  return exports.trim(str);\r\n};\r\n\r\n/**\r\n * Escape regular expression characters in `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.escapeRegexp = function(str){\r\n  return str.replace(/[-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\r\n};\r\n\r\n/**\r\n * Trim the given `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.trim = function(str){\r\n  return str.replace(/^\\s+|\\s+$/g, '');\r\n};\r\n\r\n/**\r\n * Parse the given `qs`.\r\n *\r\n * @param {String} qs\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nexports.parseQuery = function(qs){\r\n  return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair){\r\n    var i = pair.indexOf('=')\r\n      , key = pair.slice(0, i)\r\n      , val = pair.slice(++i);\r\n\r\n    obj[key] = decodeURIComponent(val);\r\n    return obj;\r\n  }, {});\r\n};\r\n\r\n/**\r\n * Highlight the given string of `js`.\r\n *\r\n * @param {String} js\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction highlight(js) {\r\n  return js\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\r\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\r\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\r\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\r\n    .replace(/\\bnew *(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\r\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>')\r\n}\r\n\r\n/**\r\n * Highlight the contents of tag `name`.\r\n *\r\n * @param {String} name\r\n * @api private\r\n */\r\n\r\nexports.highlightTags = function(name) {\r\n  var code = document.getElementsByTagName(name);\r\n  for (var i = 0, len = code.length; i < len; ++i) {\r\n    code[i].innerHTML = highlight(code[i].innerHTML);\r\n  }\r\n};\r\n\r\n}); // module: utils.js\r\n/**\r\n * Node shims.\r\n *\r\n * These are meant only to allow\r\n * mocha.js to run untouched, not\r\n * to allow running node code in\r\n * the browser.\r\n */\r\n\r\nvar process = {};\r\nprocess.exit = function(status){};\r\nprocess.stdout = {};\r\nglobal = window;\r\n\r\n/**\r\n * Remove uncaughtException listener.\r\n */\r\n\r\nprocess.removeListener = function(e){\r\n  if ('uncaughtException' == e) {\r\n    window.onerror = null;\r\n  }\r\n};\r\n\r\n/**\r\n * Implements uncaughtException listener.\r\n */\r\n\r\nprocess.on = function(e, fn){\r\n  if ('uncaughtException' == e) {\r\n    window.onerror = function(err, url, line){\r\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\r\n    };\r\n  }\r\n};\r\n\r\n// boot\r\n;(function(){\r\n\r\n  /**\r\n   * Expose mocha.\r\n   */\r\n\r\n  var Mocha = window.Mocha = require('mocha'),\r\n      mocha = window.mocha = new Mocha({ reporter: 'html' });\r\n\r\n  var immediateQueue = []\r\n    , immediateTimeout;\r\n\r\n  function timeslice() {\r\n    var immediateStart = new Date().getTime();\r\n    while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\r\n      immediateQueue.shift()();\r\n    }\r\n    if (immediateQueue.length) {\r\n      immediateTimeout = setTimeout(timeslice, 0);\r\n    } else {\r\n      immediateTimeout = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * High-performance override of Runner.immediately.\r\n   */\r\n\r\n  Mocha.Runner.immediately = function(callback) {\r\n    immediateQueue.push(callback);\r\n    if (!immediateTimeout) {\r\n      immediateTimeout = setTimeout(timeslice, 0);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Override ui to ensure that the ui functions are initialized.\r\n   * Normally this would happen in Mocha.prototype.loadFiles.\r\n   */\r\n\r\n  mocha.ui = function(ui){\r\n    Mocha.prototype.ui.call(this, ui);\r\n    this.suite.emit('pre-require', window, null, this);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Setup mocha with the given setting options.\r\n   */\r\n\r\n  mocha.setup = function(opts){\r\n    if ('string' == typeof opts) opts = { ui: opts };\r\n    for (var opt in opts) this[opt](opts[opt]);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Run mocha, returning the Runner.\r\n   */\r\n\r\n  mocha.run = function(fn){\r\n    var options = mocha.options;\r\n    mocha.globals('location');\r\n\r\n    var query = Mocha.utils.parseQuery(window.location.search || '');\r\n    if (query.grep) mocha.grep(query.grep);\r\n    if (query.invert) mocha.invert();\r\n\r\n    return Mocha.prototype.run.call(mocha, function(){\r\n      Mocha.utils.highlightTags('code');\r\n      if (fn) fn();\r\n    });\r\n  };\r\n})();\r\n})();"]],"start1":0,"start2":0,"length1":0,"length2":116090}]],"length":116090,"saved":false}
